/**
 * „ÅÇ„Çä„Åå„Å®„ÅÜ„Ç∏„É£„Éº„Éä„É´ - „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„É≠„Ç∏„ÉÉ„ÇØ (Firebase Enabled)
 * PWA + Firestore
 */

// Import Firebase
import { db } from './firebase-config.js';
import {
    collection,
    addDoc,
    setDoc,
    getDocs,
    getDoc, // Added getDoc
    onSnapshot,
    query,
    where,
    orderBy,
    doc,
    updateDoc,
    arrayUnion,
    arrayRemove,
    deleteDoc
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

// ============================
// „Éá„Éº„ÇøÁÆ°ÁêÜ (Firestore)
// ============================

const STORAGE_KEYS = {
    CURRENT_USER: 'arigato_current_user'
    // USERS and MESSAGES keys are no longer needed for storage, but we might use them for cache logic if needed (skipping for now)
};

// „É¶„Éº„Ç∂„ÉºÁÆ°ÁêÜ

// Get all users (Consider caching or pagination for large user bases, but fine for now)
async function getUsers() {
    const querySnapshot = await getDocs(collection(db, "users"));
    const users = [];
    querySnapshot.forEach((doc) => {
        users.push(doc.data());
    });
    return users;
}

// Find user by ID (optimized to fetch single doc)
async function findUser(userId) {
    const docRef = doc(db, "users", userId);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
        return docSnap.data();
    } else {
        return null; // or undefined
    }
}

async function saveUser(user) {
    await setDoc(doc(db, "users", user.userId), user);
}


async function createUser(userId, name, password) {
    // Check if exists first (should be done in handleRegister, but safety here)
    const exists = await findUser(userId);
    if (exists) throw new Error("User already exists");

    const newUser = {
        userId: userId,
        name: name,
        password: password, // Note: storing plain text password is insecure. Should allow generic auth later.
        bio: '',
        avatar: 'üë§',
        following: [],
        blocked: [],
        createdAt: Date.now()
    };

    await setDoc(doc(db, "users", userId), newUser);
    return newUser;
}

// Session Management (still local for keeping login state across reloads)
function getCurrentUser() {
    const userData = localStorage.getItem(STORAGE_KEYS.CURRENT_USER);
    return userData ? JSON.parse(userData) : null;
}

function setCurrentUser(user) {
    localStorage.setItem(STORAGE_KEYS.CURRENT_USER, JSON.stringify(user));
}

function clearCurrentUser() {
    localStorage.removeItem(STORAGE_KEYS.CURRENT_USER);
}

// Reflected User Data
// To ensure session user data is up to date (e.g. new followers), we should re-fetch me.
async function refreshCurrentUser() {
    const current = getCurrentUser();
    if (current) {
        const fresh = await findUser(current.userId);
        if (fresh) setCurrentUser(fresh);
        return fresh;
    }
    return null;
}


// „É°„ÉÉ„Çª„Éº„Ç∏ÁÆ°ÁêÜ
// We will use a real-time listener (onSnapshot) in the UI logic.
// But valid "get" helpers are nice for synchronous-like checks.

// Send Message
async function sendMessage(toId, toName, message, options = {}) {
    const currentUser = getCurrentUser();
    if (!currentUser) return null;

    const newMessage = {
        fromId: currentUser.userId,
        fromName: currentUser.name,
        toId: toId,
        toName: toName,
        message: message,
        createdAt: Date.now(),
        isRead: false,
        replyTo: options.replyTo || null,
        rootId: options.rootId || null
    };

    // Add to collection. ID is auto-generated by Firestore.
    // We can also use a custom ID msg_timestamp if we want strict sorting control but Firestore IDs are fine.
    const docRef = await addDoc(collection(db, "messages"), newMessage);

    // Return with ID
    return { id: docRef.id, ...newMessage };
}

// Delete Message
async function deleteMessage(messageId) {
    if (!confirm('„Åì„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏Ôºà„Çπ„É¨„ÉÉ„ÉâÂÖ®‰ΩìÔºâ„ÇíÂâäÈô§„Åó„Å¶„ÇÇ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü')) return;

    try {
        // 1. Find the message to check if it's a root message
        const msgDoc = await getDoc(doc(db, "messages", messageId));
        if (!msgDoc.exists()) return;
        const msgData = msgDoc.data();

        // 2. If it's a root message (no rootId), delete all replies
        if (!msgData.rootId) {
            const q = query(collection(db, "messages"), where("rootId", "==", messageId));
            const querySnapshot = await getDocs(q);

            const deletePromises = [];
            querySnapshot.forEach((document) => {
                deletePromises.push(deleteDoc(doc(db, "messages", document.id)));
            });
            await Promise.all(deletePromises);
        }

        // 3. Delete the message itself
        await deleteDoc(doc(db, "messages", messageId));
        showToast('„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü');
    } catch (err) {
        console.error("Error deleting message:", err);
        showToast('ÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
}

// Mark as Read
async function markMessagesAsRead(userId, partnerId, options = {}) {
    const qConstraints = [
        where("toId", "==", userId),
        where("isRead", "==", false)
    ];

    if (options.rootId) {
        // Mark specific thread as read
        const threadMessagesQuery = query(
            collection(db, "messages"),
            ...qConstraints,
            where("rootId", "==", options.rootId)
        );
        const threadSnapshot = await getDocs(threadMessagesQuery);
        for (const docSnap of threadSnapshot.docs) {
            await updateDoc(doc(db, "messages", docSnap.id), { isRead: true });
        }

        // Also check root message
        const rootDoc = await getDoc(doc(db, "messages", options.rootId));
        if (rootDoc.exists()) {
            const data = rootDoc.data();
            if (data.toId === userId && !data.isRead) {
                await updateDoc(doc(db, "messages", options.rootId), { isRead: true });
            }
        }
    } else if (partnerId && options.type) {
        // Mark only messages belonging to this history type as read
        // Filter locally from cachedMessages to find IDs
        const toMark = cachedMessages.filter(m => {
            if (m.toId !== userId || m.fromId !== partnerId || m.isRead) return false;

            if (options.type === 'received') {
                if (!m.rootId) return true; // Root is definitely received
                const root = cachedMessages.find(r => r.id === m.rootId);
                return root && root.toId === userId; // Started by others
            } else if (options.type === 'sent') {
                if (!m.rootId) return false; // Root started by me is NOT Received history (wait, Sent history detail shows root messages I sent)
                const root = cachedMessages.find(r => r.id === m.rootId);
                return root && root.fromId === userId; // Started by me
            }
            return false;
        });

        for (const m of toMark) {
            await updateDoc(doc(db, "messages", m.id), { isRead: true });
        }
    }
}


// ============================
// UI Logic & State
// ============================

// Local State caches for rendering
let cachedMessages = [];
let cachedUsers = [];
let currentReplyContext = null;

// Listeners
let unsubscribeMessages = null;
let unsubscribeUsers = null;

// ... (Rest of UI Logic, heavily retained but updated for Async) ...
// We need to initialize listeners on login (main screen)

const elements = {}; // Re-populate

function initializeElements() {
    elements.loginScreen = document.getElementById('login-screen');
    elements.registerScreen = document.getElementById('register-screen');
    elements.mainScreen = document.getElementById('main-screen');

    if (elements.loginScreen) {
        elements.loginForm = document.getElementById('login-form');
        elements.usernameInput = document.getElementById('username');
        elements.passwordInput = document.getElementById('password');
    }

    if (elements.registerScreen) {
        elements.registerForm = document.getElementById('register-form');
        elements.regUserIdInput = document.getElementById('reg-userid');
        elements.regUsernameInput = document.getElementById('reg-username');
        elements.regPasswordInput = document.getElementById('reg-password');
    }

    if (elements.mainScreen) {
        // ... (Same as before)
        elements.currentUserBadge = document.getElementById('current-user');
        elements.logoutBtn = document.getElementById('logout-btn');
        elements.tabBtns = document.querySelectorAll('.tab-btn');
        elements.tabContents = document.querySelectorAll('.tab-content');
        elements.sendForm = document.getElementById('send-form');
        elements.recipientSelect = document.getElementById('recipient');
        elements.messageInput = document.getElementById('message');
        elements.timelineList = document.getElementById('timeline-list');
        elements.receivedBadge = document.getElementById('received-badge');
        elements.sentBadge = document.getElementById('sent-badge');

        elements.receivedSendersList = document.getElementById('received-senders-list');
        elements.receivedMessagesDetail = document.getElementById('received-messages-detail');
        elements.detailSenderName = document.getElementById('detail-sender-name');
        elements.detailMessagesList = document.getElementById('detail-messages-list');

        elements.sentRecipientsList = document.getElementById('sent-recipients-list');
        elements.sentMessagesDetail = document.getElementById('sent-messages-detail');
        elements.detailRecipientName = document.getElementById('detail-recipient-name');
        elements.detailSentMessagesList = document.getElementById('detail-sent-messages-list');

        elements.searchUserIdInput = document.getElementById('search-userid');
        elements.searchResult = document.getElementById('search-result');
        elements.followingList = document.getElementById('following-list');
        elements.blockedList = document.getElementById('blocked-list');
        elements.blockedListToggle = document.getElementById('blocked-list-toggle');
        elements.followerList = document.getElementById('follower-list');
        elements.followerListToggle = document.getElementById('follower-list-toggle');

        elements.followingListToggle = document.getElementById('following-list-toggle');

        elements.listTypeSelect = document.getElementById('list-type-select');
        elements.followingListWrapper = document.getElementById('following-list-wrapper');
        elements.followerListWrapper = document.getElementById('follower-list-wrapper');
        elements.blockedListWrapper = document.getElementById('blocked-list-wrapper');

        elements.searchSectionToggle = document.getElementById('search-section-toggle');
        elements.searchSectionContent = document.getElementById('search-section-content');

        elements.profileModal = document.getElementById('profile-modal');
        elements.closeModal = elements.profileModal.querySelector('.close-modal');
        elements.modalUsername = document.getElementById('modal-username');
        elements.usernameEdit = document.getElementById('username-edit');
        elements.modalUserid = document.getElementById('modal-userid');
        elements.modalFollowsYouBadge = document.getElementById('modal-follows-you-badge');
        elements.modalBlocksYouBadge = document.getElementById('modal-blocks-you-badge');
        elements.profileAvatarDisplay = document.getElementById('profile-avatar-display');
        elements.followingCount = document.getElementById('following-count');
        elements.followerCount = document.getElementById('follower-count');
        elements.bioDisplay = document.getElementById('bio-display');
        elements.bioEdit = document.getElementById('bio-edit');
        elements.avatarUpload = document.getElementById('avatar-upload');
        elements.avatarEditOverlay = document.getElementById('avatar-edit-overlay');

        elements.modalActionBtn = document.getElementById('modal-action-btn');
        elements.modalBlockBtn = document.getElementById('modal-block-btn');
        elements.modalEditBtn = document.getElementById('modal-edit-btn');
        elements.modalSaveBtn = document.getElementById('modal-save-btn');
        elements.modalCancelBtn = document.getElementById('modal-cancel-btn');
        elements.modalThanksBtn = document.getElementById('modal-thanks-btn');

        elements.threadModal = document.getElementById('thread-modal');
        elements.closeThreadModal = elements.threadModal.querySelector('.close-modal');
        elements.threadMessagesList = document.getElementById('thread-messages-list');
        elements.threadReplyForm = document.getElementById('thread-reply-form');
        elements.threadInput = document.getElementById('thread-input');

        elements.toast = document.getElementById('toast');
    }

    elements.toast = document.getElementById('toast');
}


// Setup Realtime Listeners
function setupListeners() {
    // Listen for Messages
    const q = query(collection(db, "messages"), orderBy("createdAt", "desc"));
    unsubscribeMessages = onSnapshot(q, (snapshot) => {
        cachedMessages = [];
        snapshot.forEach((doc) => {
            cachedMessages.push({ id: doc.id, ...doc.data() });
        });

        // Re-render current views
        const activeTab = document.querySelector('.tab-btn.active')?.dataset.tab;

        // If a detail view is open, update ONLY that detail view to avoid flicker
        // Otherwise, update the list view
        if (activeTab === 'timeline') {
            renderTimeline();
        } else if (activeTab === 'received') {
            if (currentReceivedPartnerId) {
                showReceivedDetail(currentReceivedPartnerId);
            } else {
                renderReceivedMessages();
            }
        } else if (activeTab === 'sent') {
            if (currentSentPartnerId) {
                showSentDetail(currentSentPartnerId);
            } else {
                renderSentMessages();
            }
        }

        if (currentThreadContext) renderThreadMessages();

        // Always update badges
        updateAllBadges();
    });

    // Listen for Users (e.g. if someone changes name, or I get followed)
    unsubscribeUsers = onSnapshot(collection(db, "users"), (snapshot) => {
        cachedUsers = [];
        snapshot.forEach((doc) => {
            cachedUsers.push(doc.data());
        });

        // Refresh my session data in case I was updated (e.g. followed/blocked)
        refreshCurrentUser().then(() => {
            const currentUser = getCurrentUser();
            if (currentUser) {
                // Update Recipient Select unconditionally so it's ready for any Send Thanks action
                const followingIds = currentUser.following || [];
                const followingUsers = cachedUsers.filter(u => followingIds.includes(u.userId));
                updateRecipientSelect(followingUsers);
            }

            const activeTab = document.querySelector('.tab-btn.active')?.dataset.tab;
            if (activeTab === 'friends') {
                renderFollowingList();
                renderFollowerList();
                renderBlockedList();
                renderSearchResult();
            }
        });
    });
}


// Re-implement Render Functions using cachedMessages/cachedUsers
// These are largely identical to original but use the global cached arrays.

function updateAllBadges(messagesInput) {
    const messages = messagesInput || cachedMessages;
    const currentUser = getCurrentUser();
    if (!currentUser) return;

    const blocked = currentUser.blocked || [];
    let receivedUnread = 0;
    let sentUnread = 0;

    messages.forEach(m => {
        // Only count unread messages sent TO the current user from non-blocked users
        if (m.toId === currentUser.userId && !m.isRead && !blocked.includes(m.fromId)) {
            if (!m.rootId) {
                // New Root Message (Someone sent me a Thank You) -> Received History
                receivedUnread++;
            } else {
                // It's a reply. We need to check who started the thread.
                const rootMsg = cachedMessages.find(root => root.id === m.rootId);
                if (rootMsg) {
                    if (rootMsg.fromId === currentUser.userId) {
                        // I started this thread -> Sent History
                        sentUnread++;
                    } else if (rootMsg.toId === currentUser.userId) {
                        // Someone else started this thread to thank me -> Received History
                        receivedUnread++;
                    }
                } else {
                    // Fallback: If root message not found, default to Received
                    receivedUnread++;
                }
            }
        }
    });

    updateReceivedBadge(receivedUnread);
    updateSentBadge(sentUnread);
}


// ... (Paste utility functions: formatDate, escapeHtml, showToast, etc.) ...
// ... (Paste render functions: createMessageCard, renderTimeline, etc. using cachedMessages) ...
// ... (Paste event handlers: handleLogin -> async, etc.) ...

// I'll define essential helpers here to make the file complete in one go.

function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function formatDate(dateInput) {
    const date = new Date(dateInput);
    const yyyy = date.getFullYear();
    const mm = String(date.getMonth() + 1).padStart(2, '0');
    const dd = String(date.getDate()).padStart(2, '0');
    const hh = String(date.getHours()).padStart(2, '0');
    const min = String(date.getMinutes()).padStart(2, '0');
    return `${yyyy}/${mm}/${dd} ${hh}:${min}`;
}

function updateReceivedBadge(count) {
    if (!elements.receivedBadge) return;
    elements.receivedBadge.textContent = count > 0 ? count : '';
    count > 0 ? elements.receivedBadge.classList.remove('hidden') : elements.receivedBadge.classList.add('hidden');
}

function updateSentBadge(count) {
    if (!elements.sentBadge) return;
    elements.sentBadge.textContent = count > 0 ? count : '';
    count > 0 ? elements.sentBadge.classList.remove('hidden') : elements.sentBadge.classList.add('hidden');
}

let toastTimeout;
function showToast(message) {
    if (!elements.toast) {
        // Fallback if toast element missing (e.g. partial semantic change or race condition)
        console.warn("Toast element missing, using alert:", message);
        // Only alert for errors/validation to avoid spam, but here we want feedback
        if (message.includes('Â§±Êïó') || message.includes('ÈÅ∏Êäû') || message.includes('ÂÖ•Âäõ')) {
            alert(message);
        }
        return;
    }
    if (toastTimeout) clearTimeout(toastTimeout);
    const toastMessage = elements.toast.querySelector('.toast-message');
    if (toastMessage) toastMessage.textContent = message;

    elements.toast.classList.remove('hidden');
    elements.toast.classList.add('show');
    toastTimeout = setTimeout(() => {
        elements.toast.classList.remove('show');
        setTimeout(() => elements.toast.classList.add('hidden'), 300);
    }, 3000);
}

// ... Card Creation ...
function createMessageCard(msg, type = 'timeline', latestTime = null, hasUnread = false) {
    const currentUser = getCurrentUser();
    const isOwn = msg.fromId === currentUser.userId;

    // Determine card classes
    let cardClass = `message-card ${isOwn ? 'own-message' : ''}`;
    if (msg.isRead === false && msg.toId === currentUser.userId) {
        cardClass += ' unread';
    }

    // Thread Button
    const threadBtn = `<button class="reply-btn" onclick="window.openThread('${msg.id}')">üí¨ „Çπ„É¨„ÉÉ„Éâ</button>`;

    // Delete Button (only own)
    const deleteBtn = isOwn ? `<button class="delete-btn" onclick="window.deleteMessage('${msg.id}')">üóëÔ∏è</button>` : '';

    // User Display
    let userDisplay = '';
    const nameStyle = 'cursor:pointer; text-decoration:underline;';

    if (type === 'timeline') {
        userDisplay = `
            <div class="message-users">
                <span class="message-from" style="${nameStyle}" onclick="event.stopPropagation(); window.showUserProfile('${msg.fromId}')">${escapeHtml(msg.fromName)}</span>
                <span class="message-arrow">‚Üí</span>
                <span class="message-to" style="${nameStyle}" onclick="event.stopPropagation(); window.showUserProfile('${msg.toId}')">${escapeHtml(msg.toName)}</span>
                ${threadBtn}
                ${deleteBtn}
            </div>
        `;
    } else if (type === 'received') {
        userDisplay = `<div class="message-users" style="display:flex; align-items:center; gap:8px;"><span class="message-from" style="${nameStyle}" onclick="event.stopPropagation(); window.showUserProfile('${msg.fromId}')">${escapeHtml(msg.fromName)}</span>${(msg.isRead === false && msg.toId === currentUser.userId) ? '<span class="unread-dot"></span>' : ''}${threadBtn}${deleteBtn}</div>`;
    } else if (type === 'sent') {
        userDisplay = `<div class="message-users" style="display:flex; align-items:center; gap:8px;"><span class="message-to" style="${nameStyle}" onclick="event.stopPropagation(); window.showUserProfile('${msg.toId}')">${escapeHtml(msg.toName)}</span>${(msg.isRead === false && msg.toId === currentUser.userId) ? '<span class="unread-dot"></span>' : ''}${threadBtn}${deleteBtn}</div>`;
    } else if (type === 'thread') {
        userDisplay = `
            <div class="message-users">
                <span class="message-from" style="${nameStyle}" onclick="event.stopPropagation(); window.showUserProfile('${msg.fromId}')">${escapeHtml(msg.fromName)}</span>
                ${deleteBtn}
            </div>
        `;
    }

    // Time & Badges
    const timeToUse = latestTime || msg.createdAt;
    const timeLabel = latestTime ? 'ÊúÄÊñ∞: ' : '';
    let extraBadges = '';

    return `
        <div class="${cardClass}" id="msg-${msg.id}">
            <div class="message-header">
                ${userDisplay}
                ${type !== 'thread' ? `
                <div class="message-meta" style="font-size: 0.8em; color: var(--text-secondary); display:flex; flex-direction: column; align-items: flex-end; gap: 4px;">
                    <div>${timeLabel}${formatDate(timeToUse)}</div>
                    ${(msg.isRead === false && msg.toId === currentUser.userId) ?
                (type === 'received' || type === 'sent' ? '<span class="unread-dot"></span>' : '<span class="badge" style="background:var(--pink-500); color:white; padding:2px 8px; border-radius:12px; font-size:0.8em;">New</span>')
                : ''}
                </div>` : ''}
            </div>

            <div class="message-body">
                ${(msg.replyTo && type !== 'sent' && type !== 'received') ? `
                    <div class="reply-context">
                        <span class="reply-link-name">${escapeHtml(msg.replyTo.name)}„Åï„Çì„Å∏„ÅÆËøî‰ø°</span>
                        "${escapeHtml(msg.replyTo.text)}"
                    </div>
                ` : ''}
                <div class="message-text">
                    ${escapeHtml(msg.message)}
                </div>
                <div class="message-footer" style="text-align: right; font-size: 0.75em; color: var(--text-light); margin-top: 4px;">
                    ${formatDate(msg.createdAt)}
                </div>
            </div>
        </div>
    `;
}

// ... Async Event Handlers ...

async function handleLogin(e) {
    e.preventDefault();
    const userId = elements.usernameInput.value.trim();
    const password = elements.passwordInput.value.trim();

    if (!userId || !password) {
        showToast('„É¶„Éº„Ç∂„ÉºID„Å®„Éë„Çπ„ÉØ„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
        return;
    }

    try {
        const user = await findUser(userId);
        if (!user || user.password !== password) {
            showToast('„É¶„Éº„Ç∂„ÉºID„Åæ„Åü„ÅØ„Éë„Çπ„ÉØ„Éº„Éâ„ÅåÈñìÈÅï„Å£„Å¶„ÅÑ„Åæ„Åô');
            return;
        }

        setCurrentUser(user);
        showToast(`„Åä„Åã„Åà„Çä„Å™„Åï„ÅÑ„ÄÅ${user.name}„Åï„ÇìÔºÅ`);
        setTimeout(() => window.location.href = 'top.html', 1000);
    } catch (err) {
        console.error(err);
        if (err.code === 'unavailable' || err.message.includes('offline')) {
            showToast('„Ç™„Éï„É©„Ç§„É≥„ÅÆ„Åü„ÇÅ„É≠„Ç∞„Ç§„É≥„Åß„Åç„Åæ„Åõ„Çì„ÄÇ„Ç§„É≥„Çø„Éº„Éç„ÉÉ„ÉàÊé•Á∂ö„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
        } else {
            showToast('„É≠„Ç∞„Ç§„É≥‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü');
        }
    }
}

async function handleRegister(e) {
    e.preventDefault();
    const userId = elements.regUserIdInput.value.trim();
    const username = elements.regUsernameInput.value.trim();
    const password = elements.regPasswordInput.value.trim();

    if (!userId || !username || !password) {
        showToast('„Åô„Åπ„Å¶„ÅÆÈ†ÖÁõÆ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
        return;
    }

    try {
        const newUser = await createUser(userId, username, password);
        setCurrentUser(newUser);
        showToast(`„Çà„ÅÜ„Åì„Åù„ÄÅ${username}„Åï„ÇìÔºÅ`);
        setTimeout(() => window.location.href = 'top.html', 1000);
    } catch (err) {
        console.error(err);
        showToast('ÁôªÈå≤‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„ÅüÔºàIDÈáçË§á„Å™„Å©Ôºâ');
    }
}

function handleLogout() {
    clearCurrentUser();
    window.location.href = 'index.html';
}

// Helper to reset reply state
function cancelReply() {
    currentReplyContext = null;
    const replyPreview = document.querySelector('.reply-preview'); // Assuming a UI element exists or will be added
    if (replyPreview) {
        replyPreview.remove();
        // and/or hide container
    }
    // Also clear visual cues in input if any
}

async function handleSendMessage(e) {
    e.preventDefault();
    const recipientId = elements.recipientSelect.value;
    const recipientOption = elements.recipientSelect.options[elements.recipientSelect.selectedIndex];
    const recipientName = recipientOption ? recipientOption.dataset.name : '';
    const message = elements.messageInput.value.trim();

    if (!recipientId) {
        showToast('ÈÄÅ‰ø°ÂÖà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
        return;
    }
    if (!message) {
        showToast('„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
        return;
    }

    const options = {};
    if (currentReplyContext) options.replyTo = currentReplyContext;

    try {
        await sendMessage(recipientId, recipientName, message, options);
        showToast(`${recipientName}„Åï„Çì„Å´„ÅÇ„Çä„Åå„Å®„ÅÜ„ÇíÈÄÅ„Çä„Åæ„Åó„ÅüÔºÅ`);
        elements.messageInput.value = '';
        elements.recipientSelect.value = '';
        cancelReply();
        // UI updates automatically via listener
    } catch (err) {
        console.error(err);
        showToast('ÈÄÅ‰ø°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
}

// Global Wrappers for OnClick (Since module scope is not global)
window.showUserProfile = async (userId) => {
    // Need to implement showProfile logic fetching from cachedUsers or DB
    // For simplicity, fetch fresh
    const user = cachedUsers.find(u => u.userId === userId) || await findUser(userId);
    if (user) renderProfileModal(user);
};

window.toggleFollow = async (targetUserId) => {
    let currentUser = await refreshCurrentUser();
    if (!currentUser) return;

    const userRef = doc(db, "users", currentUser.userId);
    let isFollowing = currentUser.following && currentUser.following.includes(targetUserId);

    // Toggle logic
    if (isFollowing) {
        await updateDoc(userRef, {
            following: arrayRemove(targetUserId)
        });
        showToast('„Éï„Ç©„É≠„Éº„ÇíËß£Èô§„Åó„Åæ„Åó„Åü');
        isFollowing = false; // Update local state immediately
    } else {
        await updateDoc(userRef, {
            following: arrayUnion(targetUserId)
        });
        showToast('„Éï„Ç©„É≠„Éº„Åó„Åæ„Åó„Åü');
        isFollowing = true;
    }

    // Refresh global state
    currentUser = await refreshCurrentUser();

    // 1. Update Profile Modal if Open
    if (elements.profileModal.classList.contains('show') && currentProfileUserId === targetUserId) {
        elements.modalActionBtn.textContent = isFollowing ? '„Éï„Ç©„É≠„Éº‰∏≠' : '„Éï„Ç©„É≠„Éº„Åô„Çã';
        elements.modalActionBtn.className = 'btn btn-primary profile-action-btn';

        // Update Thanks Button state
        elements.modalThanksBtn.disabled = !isFollowing;
        elements.modalThanksBtn.className = isFollowing ? 'btn btn-success profile-action-btn' : 'btn btn-disabled-white profile-action-btn';
        elements.modalThanksBtn.style.opacity = '1';

        // Optimistically update follower count on the modal
        const currentCount = parseInt(elements.followerCount.textContent) || 0;
        elements.followerCount.textContent = isFollowing ? currentCount + 1 : Math.max(0, currentCount - 1);
    }

    // 2. Update Buttons in Lists (Search, Friends, Followers)
    const btns = document.querySelectorAll(`button[onclick="window.toggleFollow('${targetUserId}')"]`);
    btns.forEach(btn => {
        // Different text logic based on context, but generally:
        if (btn.closest('.user-card')) {
            btn.textContent = isFollowing ? '„Éï„Ç©„É≠„Éº‰∏≠' : '„Éï„Ç©„É≠„Éº';
            btn.className = 'btn btn-sm btn-primary';
        }
    });

    // 3. Always refresh Recipient Select (for Thanks tab) since following changed
    const followingIds = currentUser.following || [];
    let followingUsers = cachedUsers.filter(u => followingIds.includes(u.userId));

    // Robustness: If target user isn't in cachedUsers (e.g. fresh search), fetch & add
    if (followingIds.includes(targetUserId) && !followingUsers.find(u => u.userId === targetUserId)) {
        try {
            const missingUser = await findUser(targetUserId);
            if (missingUser) {
                followingUsers.push(missingUser);
                // Also update cache so subsequent renders work
                if (!cachedUsers.find(u => u.userId === targetUserId)) {
                    cachedUsers.push(missingUser);
                }
            }
        } catch (e) {
            console.error("Failed to fetch followed user for list:", e);
        }
    }

    updateRecipientSelect(followingUsers);

    // 4. If in Friends Tab, refresh lists to move/remove users if needed
    const activeTab = document.querySelector('.tab-btn.active');
    if (activeTab && activeTab.dataset.tab === 'friends') {
        renderFollowingList();
        renderFollowerList();
    }
};

window.toggleBlock = async (targetUserId) => {
    let currentUser = await refreshCurrentUser();
    if (!currentUser) return;

    if (!confirm('„Åì„ÅÆ„É¶„Éº„Ç∂„Éº„Çí„Éñ„É≠„ÉÉ„ÇØ/Ëß£Èô§„Åó„Åæ„Åô„ÅãÔºü')) return;

    const userRef = doc(db, "users", currentUser.userId);
    let blocked = currentUser.blocked || [];
    let isBlocked = blocked.includes(targetUserId);

    if (isBlocked) {
        await updateDoc(userRef, {
            blocked: arrayRemove(targetUserId)
        });
        showToast('„Éñ„É≠„ÉÉ„ÇØ„ÇíËß£Èô§„Åó„Åæ„Åó„Åü');
        isBlocked = false;
    } else {
        // Block and also Unfollow if following (Me -> Them)
        const updates = {
            blocked: arrayUnion(targetUserId)
        };

        if (currentUser.following && currentUser.following.includes(targetUserId)) {
            updates.following = arrayRemove(targetUserId);
        }

        await updateDoc(userRef, updates);

        // Also remove ME from THEIR following list (Them -> Me) [Mutual Unfollow]
        try {
            const targetRef = doc(db, "users", targetUserId);
            // We assume target user doc exists
            await updateDoc(targetRef, {
                following: arrayRemove(currentUser.userId)
            });
        } catch (e) {
            console.error("Error removing follower on block:", e);
        }

        showToast('„Éñ„É≠„ÉÉ„ÇØ„Åó„Åæ„Åó„Åü');
        isBlocked = true;
    }

    // Refresh
    currentUser = await refreshCurrentUser();

    // Always refresh Recipient Select since following changed (Unfollow on Block)
    const followingIds = currentUser.following || [];
    const followingUsers = cachedUsers.filter(u => followingIds.includes(u.userId));
    updateRecipientSelect(followingUsers);

    // 1. Update Profile Modal if Open
    if (elements.profileModal.classList.contains('show') && currentProfileUserId === targetUserId) {
        elements.modalBlockBtn.textContent = isBlocked ? '„Éñ„É≠„ÉÉ„ÇØ‰∏≠' : '„Éñ„É≠„ÉÉ„ÇØ';
        elements.modalBlockBtn.className = isBlocked ? 'btn btn-blocking profile-action-btn' : 'btn btn-danger profile-action-btn';

        // Disable Follow button if blocked
        elements.modalActionBtn.disabled = isBlocked;
        elements.modalActionBtn.style.opacity = isBlocked ? '1' : '1';

        const isFollowing = currentUser.following && currentUser.following.includes(targetUserId);
        if (isBlocked) {
            elements.modalActionBtn.textContent = '„Éï„Ç©„É≠„Éº‰∏çÂèØ';
            elements.modalActionBtn.className = 'btn btn-disabled-white profile-action-btn';
        } else {
            elements.modalActionBtn.textContent = isFollowing ? '„Éï„Ç©„É≠„Éº‰∏≠' : '„Éï„Ç©„É≠„Éº„Åô„Çã';
            elements.modalActionBtn.className = 'btn btn-primary profile-action-btn';
        }

        elements.modalThanksBtn.disabled = !isFollowing;
        elements.modalThanksBtn.className = isFollowing ? 'btn btn-success profile-action-btn' : 'btn btn-disabled-white profile-action-btn';
        elements.modalThanksBtn.style.opacity = '1';

        // Update follows-you badge immediately
        if (isBlocked) {
            // Just unblocked. Follows-you remains false (since block removed it)
            elements.modalFollowsYouBadge.classList.add('hidden');
        } else {
            // Just blocked. Hide it.
            elements.modalFollowsYouBadge.classList.add('hidden');
        }
    }

    // 2. Refresh Lists (Blocked list, etc)
    const activeTab = document.querySelector('.tab-btn.active');
    if (activeTab && activeTab.dataset.tab === 'friends') {
        renderBlockedList();
        // If we blocked someone we were following, logic might imply unfollowing or hiding...
        // For now just refresh displayed blocked list
    }
};


window.deleteMessage = async (msgId) => {
    await deleteMessage(msgId);
};

window.openThread = (msgId) => {
    // Logic to open thread modal
    // ... Copy openThread logic but fetch from cachedMessages
    const msg = cachedMessages.find(m => m.id === msgId);
    if (!msg) return;

    const currentUser = getCurrentUser();
    const rootId = msg.rootId || msg.id;
    const otherId = (msg.fromId === currentUser.userId) ? msg.toId : msg.fromId;
    const otherName = (msg.fromId === currentUser.userId) ? msg.toName : msg.fromName;

    currentThreadContext = { rootId, otherUserId: otherId, otherUserName: otherName };
    renderThreadMessages();

    // Mark messages in this thread as read
    markMessagesAsRead(currentUser.userId, null, { rootId });

    const modal = document.getElementById('thread-modal');
    modal.classList.remove('hidden');
    void modal.offsetWidth;
    modal.classList.add('show');
};

// ... Render Implementations needed for window.openThread etc to work ...
let currentThreadContext = null;
let currentProfileUserId = null;
let currentReceivedPartnerId = null;
let currentSentPartnerId = null;

function renderThreadMessages() {
    if (!currentThreadContext) return;
    const listContainer = document.getElementById('thread-messages-list');
    listContainer.innerHTML = '';

    const threadMessages = cachedMessages.filter(m =>
        m.rootId === currentThreadContext.rootId || m.id === currentThreadContext.rootId
    ).sort((a, b) => a.createdAt - b.createdAt);

    if (threadMessages.length === 0) {
        listContainer.innerHTML = '<p>No messages</p>';
        return;
    }

    threadMessages.forEach(msg => {
        listContainer.innerHTML += createMessageCard(msg, 'thread');
    });

    setTimeout(() => listContainer.scrollTop = listContainer.scrollHeight, 10);
}

// ============================
// Render Functions (Implemented)
// ============================

function renderUserCard(user, type = 'following') {
    const currentUser = getCurrentUser();
    const isMe = user.userId === currentUser.userId;
    const isFollowing = currentUser.following && currentUser.following.includes(user.userId);
    const isBlocked = currentUser.blocked && currentUser.blocked.includes(user.userId);

    // Check if they follow you / block you
    const followsYou = user.following && user.following.includes(currentUser.userId);
    const blocksYou = user.blocked && user.blocked.includes(currentUser.userId);

    let actionBtn = '';
    let thanksBtn = '';

    if (!isMe) {
        // Shared Thanks Button Logic
        const thanksClass = isFollowing ? 'btn btn-sm btn-success' : 'btn btn-sm btn-disabled-white';
        const thanksDisabled = !isFollowing ? 'disabled' : '';

        thanksBtn = `<button class="${thanksClass}" 
            style="margin-right: 4px;"
            ${thanksDisabled}
            onclick="event.stopPropagation(); window.openSendTab('${user.userId}')">
            „ÅÇ„Çä„Åå„Å®„ÅÜ„ÇíÈÄÅ„Çã
        </button>`;

        if (isBlocked || blocksYou) {
            // Blocked State (Priority over Search/Friends logic)
            // Use btn-blocking for both cases as requested
            actionBtn = `<button class="btn btn-sm btn-blocking" onclick="window.toggleBlock('${user.userId}')">„Éñ„É≠„ÉÉ„ÇØ‰∏≠</button>`;
        } else {
            // Not Blocked
            actionBtn = `<button class="btn btn-sm btn-primary" onclick="window.toggleFollow('${user.userId}')">
                ${isFollowing ? '„Éï„Ç©„É≠„Éº‰∏≠' : '„Éï„Ç©„É≠„Éº„Åô„Çã'}
            </button>`;
        }
    }

    return `
        <div class="message-card user-card">
            <div class="user-card-content" onclick="window.showUserProfile('${user.userId}')" style="cursor:pointer; display:flex; align-items:center; gap:12px; flex:1;">
                <div class="profile-avatar sm">${user.avatar || 'üë§'}</div>
                <div class="user-info">
                    <div class="user-name">
                        ${escapeHtml(user.name)}
                        ${followsYou ? '<span class="follows-you-badge">„Éï„Ç©„É≠„Éº„Åï„Çå„Å¶„ÅÑ„Åæ„Åô</span>' : ''}
                    </div>
                    <div class="user-id">@${user.userId}</div>
                </div>
            </div>
            <div class="user-card-actions" style="display:flex; align-items:center; gap:4px;">
                ${thanksBtn}
                ${actionBtn}
            </div>
        </div>
    `;
}

// Helper to open send tab with user selected
window.openSendTab = (userId) => {
    switchTab('send');
    if (elements.recipientSelect) {
        elements.recipientSelect.value = userId;
        elements.recipientSelect.disabled = true; // Lock selection
    }
};

function renderReceivedMessages() {
    const currentUser = getCurrentUser();
    if (!currentUser) return;
    const blocked = currentUser.blocked || [];

    const messages = cachedMessages.filter(m =>
        m.toId === currentUser.userId &&
        !blocked.includes(m.fromId) &&
        !m.rootId
    );

    const senders = {};
    messages.forEach(msg => {
        if (!senders[msg.fromId]) {
            // Find the ABSOLUTE latest activity in any thread with this partner
            const allPartnerMessages = cachedMessages.filter(m =>
                (m.fromId === currentUser.userId && m.toId === msg.fromId) ||
                (m.toId === currentUser.userId && m.fromId === msg.fromId)
            );
            const absoluteLatest = allPartnerMessages.reduce((max, m) => Math.max(max, m.createdAt), 0);

            senders[msg.fromId] = {
                id: msg.fromId,
                name: msg.fromName,
                lastMessage: msg,
                absoluteLatest: absoluteLatest,
                count: 0,
                unread: 0
            };
        }
        if (msg.createdAt > senders[msg.fromId].lastMessage.createdAt) {
            senders[msg.fromId].lastMessage = msg;
        }
        senders[msg.fromId].count++;
        if (!msg.isRead) senders[msg.fromId].unread++;
    });

    const listContainer = elements.receivedSendersList;
    if (!listContainer) return;
    listContainer.innerHTML = '';
    elements.receivedMessagesDetail.classList.add('hidden');
    listContainer.classList.remove('hidden');

    const sortedSenders = Object.values(senders).sort((a, b) => b.absoluteLatest - a.absoluteLatest);

    if (sortedSenders.length === 0) {
        listContainer.innerHTML = '<div class="empty-state"><span class="empty-icon">üì≠</span><p>„Åæ„Å†„ÅÇ„Çä„Åå„Å®„ÅÜ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì</p></div>';
        return;
    }

    sortedSenders.forEach(sender => {
        const div = document.createElement('div');
        div.className = `message-card ${sender.unread > 0 ? 'unread' : ''}`;
        div.style.cursor = 'pointer';
        div.onclick = () => showReceivedDetail(sender.id);

        div.innerHTML = `
            <div class="message-header">
                <div style="display:flex; align-items:center; gap:8px;">
                    <span class="message-from" style="font-weight:bold; font-size:1.1em; cursor:pointer;" onclick="event.stopPropagation(); window.showUserProfile('${sender.id}')">
                        ${escapeHtml(sender.name)}
                    </span>
                    ${sender.unread > 0 ? '<span class="unread-dot"></span>' : ''}
                </div>
                <div style="display:flex; align-items:center;">
                     <span style="font-size:0.8em; color:var(--text-light);">ÊúÄÊñ∞: ${formatDate(sender.absoluteLatest)}</span>
                </div>
            </div>
             <div class="message-body" style="margin-top:8px;">
                <div class="message-text" style="color:var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                    ${escapeHtml(sender.lastMessage.message)}
                </div>
            </div>
        `;
        listContainer.appendChild(div);
    });
}

window.showReceivedDetail = (senderId) => {
    currentReceivedPartnerId = senderId;
    const currentUser = getCurrentUser();

    // Mark as read (Only received messages/replies)
    markMessagesAsRead(currentUser.userId, senderId, { type: 'received' });

    // 1. Calculate Latest Dates including replies across all cached messages first
    const threadLatest = {};
    cachedMessages.forEach(m => {
        const rootId = m.rootId || m.id;
        if (!threadLatest[rootId] || m.createdAt > threadLatest[rootId]) {
            threadLatest[rootId] = m.createdAt;
        }
    });

    // 2. Filter and Sort by latest thread activity
    const messages = cachedMessages.filter(m =>
        m.toId === currentUser.userId && m.fromId === senderId && !m.rootId
    ).sort((a, b) => (threadLatest[b.id] || b.createdAt) - (threadLatest[a.id] || a.createdAt));

    if (messages.length === 0) {
        // Automatically back to list if no messages left
        backToReceivedList();
        return;
    }

    elements.receivedSendersList.classList.add('hidden');
    elements.receivedMessagesDetail.classList.remove('hidden');
    elements.detailSenderName.textContent = messages[0].fromName; // Use latest name

    elements.detailMessagesList.innerHTML = messages.map(msg => {
        const latestAt = threadLatest[msg.id] || msg.createdAt;
        return createMessageCard(msg, 'received', latestAt);
    }).join('');
}

window.backToReceivedList = () => {
    currentReceivedPartnerId = null;
    elements.receivedMessagesDetail.classList.add('hidden');
    elements.receivedSendersList.classList.remove('hidden');
    renderReceivedMessages(); // Re-render to update unread status
};

function renderSentMessages() {
    const currentUser = getCurrentUser();
    if (!currentUser) return;
    // Sent messages logic...
    const messages = cachedMessages.filter(m =>
        m.fromId === currentUser.userId &&
        !m.rootId
    );

    const recipients = {};
    messages.forEach(msg => {
        if (!recipients[msg.toId]) {
            // Find the ABSOLUTE latest activity in any thread with this partner
            const allPartnerMessages = cachedMessages.filter(m =>
                (m.fromId === currentUser.userId && m.toId === msg.toId) ||
                (m.toId === currentUser.userId && m.fromId === msg.toId)
            );
            const absoluteLatest = allPartnerMessages.reduce((max, m) => Math.max(max, m.createdAt), 0);

            // Count unread replies (messages sent TO me from this partner)
            const unreadCount = allPartnerMessages.filter(m => m.toId === currentUser.userId && !m.isRead).length;

            recipients[msg.toId] = {
                id: msg.toId,
                name: msg.toName, // Snapshot name
                lastMessage: msg,
                absoluteLatest: absoluteLatest,
                unread: unreadCount,
                count: 0
            };
        }
        if (msg.createdAt > recipients[msg.toId].lastMessage.createdAt) {
            recipients[msg.toId].lastMessage = msg;
        }
        recipients[msg.toId].count++;
    });

    const listContainer = elements.sentRecipientsList;
    listContainer.innerHTML = '';
    elements.sentMessagesDetail.classList.add('hidden');
    listContainer.classList.remove('hidden');

    const sortedRecipients = Object.values(recipients).sort((a, b) => b.absoluteLatest - a.absoluteLatest);

    if (sortedRecipients.length === 0) {
        listContainer.innerHTML = '<div class="empty-state"><span class="empty-icon">‚ú®</span><p>„Åæ„Å†„ÅÇ„Çä„Åå„Å®„ÅÜ„ÇíÈÄÅ„Å£„Å¶„ÅÑ„Åæ„Åõ„Çì</p></div>';
        return;
    }

    sortedRecipients.forEach(pf => {
        const div = document.createElement('div');
        div.className = 'message-card own-message';
        div.style.cursor = 'pointer';
        div.onclick = () => showSentDetail(pf.id);
        div.innerHTML = `
             <div class="message-header">
                 <div style="display:flex; align-items:center; gap:8px;">
                    <span class="message-to" style="font-weight:bold; font-size:1.1em; cursor:pointer;" onclick="event.stopPropagation(); window.showUserProfile('${pf.id}')">
                        ${escapeHtml(pf.name)}
                    </span>
                    ${pf.unread > 0 ? '<span class="unread-dot"></span>' : ''}
                 </div>
                 <span style="font-size:0.8em; color:var(--text-light);">ÊúÄÊñ∞: ${formatDate(pf.absoluteLatest)}</span>
            </div>
             <div class="message-body" style="margin-top:8px;">
                <div class="message-text" style="color:var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                    ${escapeHtml(pf.lastMessage.message)}
                </div>
            </div>
        `;
        listContainer.appendChild(div);
    });
}

window.showSentDetail = (recipientId) => {
    currentSentPartnerId = recipientId;
    const currentUser = getCurrentUser();

    // Mark as read (Only unread replies in my sent threads)
    markMessagesAsRead(currentUser.userId, recipientId, { type: 'sent' });

    // 1. Calculate Latest Dates including replies first
    const threadLatest = {};
    cachedMessages.forEach(m => {
        const rootId = m.rootId || m.id;
        if (!threadLatest[rootId] || m.createdAt > threadLatest[rootId]) {
            threadLatest[rootId] = m.createdAt;
        }
    });

    // 2. Filter and Sort by latest thread activity
    const messages = cachedMessages.filter(m =>
        m.fromId === currentUser.userId && m.toId === recipientId && !m.rootId
    ).sort((a, b) => (threadLatest[b.id] || b.createdAt) - (threadLatest[a.id] || a.createdAt));

    if (messages.length === 0) {
        // Automatically back to list if no messages left
        backToSentList();
        return;
    }

    elements.sentRecipientsList.classList.add('hidden');
    elements.sentMessagesDetail.classList.remove('hidden');
    elements.detailRecipientName.textContent = messages[0].toName;

    elements.detailSentMessagesList.innerHTML = messages.map(msg => {
        const latestAt = threadLatest[msg.id] || msg.createdAt;
        return createMessageCard(msg, 'sent', latestAt);
    }).join('');
};

window.backToSentList = () => {
    currentSentPartnerId = null;
    elements.sentMessagesDetail.classList.add('hidden');
    elements.sentRecipientsList.classList.remove('hidden');
    renderSentMessages();
};

function renderFollowingList() {
    const currentUser = getCurrentUser();
    if (!currentUser || !elements.followingList) return;
    const followingIds = currentUser.following || [];
    const container = elements.followingList;
    container.innerHTML = '';
    const followingUsers = cachedUsers.filter(u => followingIds.includes(u.userId));

    if (followingUsers.length === 0) {
        container.innerHTML = '<div class="empty-state"><span class="empty-icon">üë•</span><p>„Åæ„Å†„Éï„Ç©„É≠„Éº„Åó„Å¶„ÅÑ„Çã‰∫∫„ÅØ„ÅÑ„Åæ„Åõ„Çì</p></div>';
    } else {
        followingUsers.forEach(user => {
            container.innerHTML += renderUserCard(user, 'following');
        });
    }
    updateRecipientSelect(followingUsers);
}

function renderFollowerList() {
    const currentUser = getCurrentUser();
    if (!currentUser || !elements.followerList) return;
    const container = elements.followerList;
    container.innerHTML = '';
    // Filter users who follow me
    const followers = cachedUsers.filter(u => u.following && u.following.includes(currentUser.userId));

    if (followers.length === 0) {
        container.innerHTML = '<div class="empty-state"><span class="empty-icon">üë•</span><p>„Åæ„Å†„Éï„Ç©„É≠„ÉØ„Éº„ÅØ„ÅÑ„Åæ„Åõ„Çì</p></div>';
    } else {
        followers.forEach(user => {
            container.innerHTML += renderUserCard(user, 'followers');
        });
    }
}

function renderBlockedList() {
    const currentUser = getCurrentUser();
    if (!currentUser || !elements.blockedList) return;
    const blockedIds = currentUser.blocked || [];
    const container = elements.blockedList;
    container.innerHTML = '';
    const blockedUsers = cachedUsers.filter(u => blockedIds.includes(u.userId));

    if (blockedUsers.length === 0) {
        container.innerHTML = '<div class="empty-state"><span class="empty-icon">üö´</span><p>„Éñ„É≠„ÉÉ„ÇØ„Åó„Å¶„ÅÑ„Çã‰∫∫„ÅØ„ÅÑ„Åæ„Åõ„Çì</p></div>';
    } else {
        blockedUsers.forEach(user => {
            container.innerHTML += renderUserCard(user, 'blocked');
        });
    }
}

function renderSearchResult() {
    const queryStr = elements.searchUserIdInput.value.trim();
    const container = elements.searchResult;
    if (!queryStr) {
        container.innerHTML = '';
        return;
    }
    // Strict match for User ID only, excluding self
    const currentUser = getCurrentUser();
    const results = cachedUsers.filter(u => u.userId === queryStr && u.userId !== currentUser.userId);

    if (results.length === 0) {
        container.innerHTML = '<p style="text-align:center; padding:16px; color:var(--text-light);">„É¶„Éº„Ç∂„ÉºID„ÅåÂÆåÂÖ®„Å´‰∏ÄËá¥„Åô„Çã„É¶„Éº„Ç∂„Éº„ÅØË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü</p>';
    } else {
        container.innerHTML = results.map(u => renderUserCard(u, 'search')).join('');
    }
}

function updateRecipientSelect(friends) {
    if (!elements.recipientSelect) return;
    const currentVal = elements.recipientSelect.value;

    elements.recipientSelect.innerHTML = '<option value="">‚ñº ÈÄÅ„Çä„Åü„ÅÑÁõ∏Êâã„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ</option>';
    friends.forEach(user => {
        const option = document.createElement('option');
        option.value = user.userId;
        option.textContent = user.name;
        option.dataset.name = user.name;
        elements.recipientSelect.appendChild(option);
    });

    // Restore selection if it still exists
    if (currentVal && friends.find(u => u.userId === currentVal)) {
        elements.recipientSelect.value = currentVal;
    }
}

function renderProfileModal(user) {
    currentProfileUserId = user.userId;
    const currentUser = getCurrentUser();
    if (!currentUser) return;

    elements.modalUsername.textContent = user.name;
    elements.modalUserid.textContent = `@${user.userId}`;
    elements.profileAvatarDisplay.textContent = user.avatar || 'üë§';
    elements.bioDisplay.textContent = user.bio || 'Ëá™Â∑±Á¥π‰ªã„ÅØ„Åæ„Å†„ÅÇ„Çä„Åæ„Åõ„Çì';

    // Stats
    const followingCount = user.following ? user.following.length : 0;
    // Calculating followers strictly needs iterating all users (expensive) or storing it.
    // We'll iterate cachedUsers for now.
    const followerCount = cachedUsers.filter(u => u.following && u.following.includes(user.userId)).length;

    elements.followingCount.textContent = followingCount;
    elements.followerCount.textContent = followerCount;

    // Reset Edit Mode
    elements.bioDisplay.classList.remove('hidden');
    elements.bioEdit.classList.add('hidden');
    elements.usernameEdit.classList.add('hidden');
    elements.modalUsername.classList.remove('hidden');
    elements.avatarEditOverlay.classList.add('hidden');

    elements.modalEditBtn.classList.add('hidden');
    elements.modalSaveBtn.classList.add('hidden');
    elements.modalCancelBtn.classList.add('hidden');
    elements.modalActionBtn.classList.add('hidden');
    elements.modalBlockBtn.classList.add('hidden');
    elements.modalThanksBtn.classList.add('hidden');

    // Check following status for Thanks button disabling
    const isFollowing = currentUser.following && currentUser.following.includes(user.userId);

    if (user.userId === currentUser.userId) {
        // Own Profile
        elements.modalEditBtn.classList.remove('hidden');
        elements.modalFollowsYouBadge.classList.add('hidden');
        elements.modalThanksBtn.classList.add('hidden'); // Ensure hidden for self
    } else {
        // Other User
        // const isFollowing = ... already calculated above
        const isBlocked = currentUser.blocked && currentUser.blocked.includes(user.userId);
        const blocksYou = user.blocked && user.blocked.includes(currentUser.userId);

        // Follow Button Logic
        if (isBlocked) {
            elements.modalActionBtn.textContent = '„Éï„Ç©„É≠„Éº‰∏çÂèØ';
            elements.modalActionBtn.className = 'btn btn-disabled-white profile-action-btn';
            elements.modalActionBtn.disabled = true;
        } else if (blocksYou) {
            elements.modalActionBtn.textContent = '„Éï„Ç©„É≠„Éº‰∏çÂèØ';
            elements.modalActionBtn.className = 'btn btn-disabled-white profile-action-btn';
            elements.modalActionBtn.disabled = true;
        } else {
            elements.modalActionBtn.textContent = isFollowing ? '„Éï„Ç©„É≠„Éº‰∏≠' : '„Éï„Ç©„É≠„Éº„Åô„Çã';
            elements.modalActionBtn.className = 'btn btn-primary profile-action-btn';
            elements.modalActionBtn.disabled = false;
        }
        elements.modalActionBtn.onclick = () => window.toggleFollow(user.userId);
        elements.modalActionBtn.classList.remove('hidden');

        elements.modalActionBtn.style.opacity = '1';

        // Thanks Button Logic
        elements.modalThanksBtn.classList.remove('hidden');
        elements.modalThanksBtn.disabled = !isFollowing; // Disable if not following
        elements.modalThanksBtn.className = isFollowing ? 'btn btn-success profile-action-btn' : 'btn btn-disabled-white profile-action-btn';
        elements.modalThanksBtn.style.opacity = '1';
        elements.modalThanksBtn.onclick = () => {
            if (!elements.modalThanksBtn.disabled) {
                elements.profileModal.classList.remove('show');
                setTimeout(() => elements.profileModal.classList.add('hidden'), 300);
                switchTab('send');
                if (elements.recipientSelect) {
                    elements.recipientSelect.value = user.userId;
                    elements.recipientSelect.disabled = true; // Lock selection
                }
            }
        };

        // Block Button Logic
        elements.modalBlockBtn.textContent = isBlocked ? '„Éñ„É≠„ÉÉ„ÇØ‰∏≠' : '„Éñ„É≠„ÉÉ„ÇØ';
        elements.modalBlockBtn.className = isBlocked ? 'btn btn-blocking profile-action-btn' : 'btn btn-danger profile-action-btn';
        elements.modalBlockBtn.onclick = () => window.toggleBlock(user.userId);
        elements.modalBlockBtn.classList.remove('hidden');

        const followsYou = user.following && user.following.includes(currentUser.userId);
        followsYou ? elements.modalFollowsYouBadge.classList.remove('hidden') : elements.modalFollowsYouBadge.classList.add('hidden');

        blocksYou ? elements.modalBlocksYouBadge.classList.remove('hidden') : elements.modalBlocksYouBadge.classList.add('hidden');
    }

    elements.profileModal.classList.remove('hidden');
    void elements.profileModal.offsetWidth;
    elements.profileModal.classList.add('show');
}
// Actually, I must implement them all or the app breaks.
// I will paste the previous render logic but pointing to cachedMessages.

function renderTimeline() {
    const currentUser = getCurrentUser();
    if (!currentUser) return;
    const blocked = currentUser.blocked || [];

    // 1. Calculate latest timestamp for each thread
    const threadLatest = {};
    cachedMessages.forEach(m => {
        const rootId = m.rootId || m.id;
        if (!threadLatest[rootId] || m.createdAt > threadLatest[rootId]) {
            threadLatest[rootId] = m.createdAt;
        }
    });

    // 2. Filter for visible root messages
    const messages = cachedMessages.filter(m =>
        (m.fromId === currentUser.userId || m.toId === currentUser.userId) &&
        !m.rootId &&
        !blocked.includes(m.fromId)
    );

    if (messages.length === 0) {
        elements.timelineList.innerHTML = '<div class="empty-state"><span class="empty-icon">üì±</span><p>„Åæ„Å†„É°„ÉÉ„Çª„Éº„Ç∏„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì</p></div>';
    } else {
        // 3. Sort by calculated latest timestamp
        const sortedMessages = messages.sort((a, b) => {
            const timeA = threadLatest[a.id] || a.createdAt;
            const timeB = threadLatest[b.id] || b.createdAt;
            return timeB - timeA;
        });

        // 4. Render
        const html = sortedMessages.map(msg => {
            const latestAt = threadLatest[msg.id] || msg.createdAt;
            return createMessageCard(msg, 'timeline', latestAt);
        }).join('');

        elements.timelineList.innerHTML = html;
    }
}

// Initialization Logic
function initialize() {
    initializeElements();

    if (document.getElementById('login-screen') || document.getElementById('register-screen')) {
        if (elements.loginForm) elements.loginForm.addEventListener('submit', handleLogin);
        if (elements.registerForm) elements.registerForm.addEventListener('submit', handleRegister);
    }

    if (document.getElementById('main-screen')) {
        const currentUser = getCurrentUser();
        if (!currentUser) {
            window.location.href = 'index.html';
            return;
        }

        // Display Current User Name
        if (elements.currentUserBadge) {
            elements.currentUserBadge.textContent = currentUser.name;
            elements.currentUserBadge.addEventListener('click', () => {
                renderProfileModal(currentUser);
            });
        }

        elements.logoutBtn.addEventListener('click', handleLogout);
        elements.sendForm.addEventListener('submit', handleSendMessage);
        elements.tabBtns.forEach(btn => btn.addEventListener('click', handleTabClick));

        // Setup Listeners
        setupListeners();

        // Initial Tab
        switchTab('timeline');

        // Friend List Toggles
        if (elements.listTypeSelect) {
            elements.listTypeSelect.addEventListener('change', (e) => {
                const type = e.target.value;
                elements.followingListWrapper.classList.toggle('hidden', type !== 'following');
                elements.followerListWrapper.classList.toggle('hidden', type !== 'followers');
                elements.blockedListWrapper.classList.toggle('hidden', type !== 'blocked');
            });
        }

        if (elements.searchSectionToggle) {
            elements.searchSectionToggle.addEventListener('click', () => {
                const content = elements.searchSectionContent;
                const icon = elements.searchSectionToggle.querySelector('.toggle-icon');
                const isHidden = content.style.display === 'none';
                content.style.display = isHidden ? 'block' : 'none';
                icon.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
                elements.searchSectionToggle.classList.toggle('collapsed', !isHidden);
            });
        }

        if (elements.searchUserIdInput) {
            elements.searchUserIdInput.addEventListener('input', renderSearchResult);
        }

        // Profile Actions
        if (elements.modalEditBtn) {
            elements.modalEditBtn.addEventListener('click', toggleProfileEdit);
            elements.modalCancelBtn.addEventListener('click', toggleProfileEdit);
            elements.modalSaveBtn.addEventListener('click', handleSaveProfile);
            elements.avatarEditOverlay.addEventListener('click', () => elements.avatarUpload.click());
            elements.avatarUpload.addEventListener('change', handleAvatarUpload);
            elements.avatarUpload.addEventListener('change', handleAvatarUpload);
        }

        // Modal Close Buttons
        if (elements.closeModal) {
            elements.closeModal.addEventListener('click', () => {
                elements.profileModal.classList.remove('show');
                setTimeout(() => elements.profileModal.classList.add('hidden'), 300);
            });
        }
        if (elements.closeThreadModal) {
            elements.closeThreadModal.addEventListener('click', () => {
                elements.threadModal.classList.remove('show');
                setTimeout(() => elements.threadModal.classList.add('hidden'), 300);
            });
        }

        // Thread Reply
        if (elements.threadReplyForm) {
            elements.threadReplyForm.addEventListener('submit', handleThreadReply);
        }

    }

}

// Tab Switching
function switchTab(tabName) {
    elements.tabBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tabName));
    elements.tabContents.forEach(content => content.classList.toggle('active', content.id === `tab-${tabName}`));

    // Reset inputs when switching manually (or generically)
    if (tabName === 'send') {
        if (elements.recipientSelect) elements.recipientSelect.disabled = false;
    }

    if (tabName === 'timeline') renderTimeline();
    else if (tabName === 'received') renderReceivedMessages();
    else if (tabName === 'sent') renderSentMessages();
    else if (tabName === 'friends') {
        renderFollowingList();
        renderFollowerList();
        renderBlockedList();
    }
}
function handleTabClick(e) {
    const tabBtn = e.target.closest('.tab-btn');
    if (tabBtn) switchTab(tabBtn.dataset.tab);
}

// Profile View Helpers
function toggleProfileEdit() {
    const isEditing = !elements.bioDisplay.classList.contains('hidden');
    elements.bioDisplay.classList.toggle('hidden', isEditing);
    elements.bioEdit.classList.toggle('hidden', !isEditing);
    elements.usernameEdit.classList.toggle('hidden', !isEditing);
    elements.modalUsername.classList.toggle('hidden', isEditing);
    elements.avatarEditOverlay.classList.toggle('hidden', !isEditing);

    elements.modalEditBtn.classList.toggle('hidden', isEditing);
    elements.modalSaveBtn.classList.toggle('hidden', !isEditing);
    elements.modalCancelBtn.classList.toggle('hidden', !isEditing);

    if (isEditing) {
        elements.bioEdit.value = elements.bioDisplay.textContent === 'Ëá™Â∑±Á¥π‰ªã„ÅØ„Åæ„Å†„ÅÇ„Çä„Åæ„Åõ„Çì' ? '' : elements.bioDisplay.textContent;
        elements.usernameEdit.value = elements.modalUsername.textContent;
    }
}

async function handleSaveProfile() {
    const currentUser = getCurrentUser();
    if (!currentUser) return;

    const newName = elements.usernameEdit.value.trim();
    const newBio = elements.bioEdit.value.trim();

    if (!newName) {
        showToast('ÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
        return;
    }

    try {
        const userRef = doc(db, "users", currentUser.userId);
        await updateDoc(userRef, {
            name: newName,
            bio: newBio
        });

        // Update UI immediately (Important for immediate feedback)
        elements.modalUsername.textContent = newName;
        elements.bioDisplay.textContent = newBio || 'Ëá™Â∑±Á¥π‰ªã„ÅØ„Åæ„Å†„ÅÇ„Çä„Åæ„Åõ„Çì';

        // Update Local Storage Session
        currentUser.name = newName;
        currentUser.bio = newBio;
        setCurrentUser(currentUser);

        // Update Header Badge
        if (elements.currentUserBadge) {
            elements.currentUserBadge.textContent = newName;
        }

        showToast('„Éó„É≠„Éï„Ç£„Éº„É´„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü');
        toggleProfileEdit();
    } catch (err) {
        console.error(err);
        showToast('Êõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
}

async function handleAvatarUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    showToast('ÁîªÂÉè„ÅÆ„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÊ©üËÉΩ„ÅØÁèæÂú®Emoij„ÅÆ„ÅøÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„ÅôÔºàÂ∞ÜÊù•ÁöÑ„Å´Storage„Å´ÂØæÂøú‰∫àÂÆöÔºâ');
}

async function handleThreadReply(e) {
    e.preventDefault();
    const message = elements.threadInput.value.trim();
    if (!message || !currentThreadContext) return;

    try {
        await sendMessage(
            currentThreadContext.otherUserId,
            currentThreadContext.otherUserName,
            message,
            { rootId: currentThreadContext.rootId }
        );
        elements.threadInput.value = '';
        renderThreadMessages(); // Optimistic update or wait for listener? Listener handles it but better to scroll
        // renderThreadMessages will be called by listener eventually, but we might want immediate feedback
    } catch (err) {
        console.error(err);
        showToast('Ëøî‰ø°„ÅÆÈÄÅ‰ø°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
}



// Start
document.addEventListener('DOMContentLoaded', initialize);

