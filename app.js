/**
 * ã‚ã‚ŠãŒã¨ã†ã‚¸ãƒ£ãƒ¼ãƒŠãƒ« - ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ (Firebase Enabled)
 * PWA + Firestore
 */

// Import Firebase
import { db } from './firebase-config.js';
import {
    collection,
    addDoc,
    setDoc,
    getDocs,
    getDoc, // Added getDoc
    onSnapshot,
    query,
    where,
    orderBy,
    doc,
    updateDoc,
    arrayUnion,
    arrayRemove,
    deleteDoc
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

// ============================
// ãƒ‡ãƒ¼ã‚¿ç®¡ç† (Firestore)
// ============================

const STORAGE_KEYS = {
    CURRENT_USER: 'arigato_current_user'
    // USERS and MESSAGES keys are no longer needed for storage, but we might use them for cache logic if needed (skipping for now)
};

// ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†

// Get all users (Consider caching or pagination for large user bases, but fine for now)
async function getUsers() {
    const querySnapshot = await getDocs(collection(db, "users"));
    const users = [];
    querySnapshot.forEach((doc) => {
        users.push(doc.data());
    });
    return users;
}

// Find user by ID (optimized to fetch single doc)
async function findUser(userId) {
    const docRef = doc(db, "users", userId);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
        return docSnap.data();
    } else {
        return null; // or undefined
    }
}

async function saveUser(user) {
    await setDoc(doc(db, "users", user.userId), user);
}


async function createUser(userId, name, password) {
    // Check if exists first (should be done in handleRegister, but safety here)
    const exists = await findUser(userId);
    if (exists) throw new Error("User already exists");

    const newUser = {
        userId: userId,
        name: name,
        password: password, // Note: storing plain text password is insecure. Should allow generic auth later.
        bio: '',
        avatar: 'ğŸ‘¤',
        following: [],
        blocked: [],
        createdAt: Date.now()
    };

    await setDoc(doc(db, "users", userId), newUser);
    return newUser;
}

// Session Management (still local for keeping login state across reloads)
function getCurrentUser() {
    const userData = localStorage.getItem(STORAGE_KEYS.CURRENT_USER);
    return userData ? JSON.parse(userData) : null;
}

function setCurrentUser(user) {
    localStorage.setItem(STORAGE_KEYS.CURRENT_USER, JSON.stringify(user));
}

function clearCurrentUser() {
    localStorage.removeItem(STORAGE_KEYS.CURRENT_USER);
}

// Reflected User Data
// To ensure session user data is up to date (e.g. new followers), we should re-fetch me.
async function refreshCurrentUser() {
    const current = getCurrentUser();
    if (current) {
        const fresh = await findUser(current.userId);
        if (fresh) setCurrentUser(fresh);
        return fresh;
    }
    return null;
}


// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç®¡ç†
// We will use a real-time listener (onSnapshot) in the UI logic.
// But valid "get" helpers are nice for synchronous-like checks.

// Send Message
async function sendMessage(toId, toName, message, options = {}) {
    const currentUser = getCurrentUser();
    if (!currentUser) return null;

    const newMessage = {
        fromId: currentUser.userId,
        fromName: currentUser.name,
        toId: toId,
        toName: toName,
        message: message,
        createdAt: Date.now(),
        isRead: false,
        replyTo: options.replyTo || null,
        rootId: options.rootId || null
    };

    // Add to collection. ID is auto-generated by Firestore.
    // We can also use a custom ID msg_timestamp if we want strict sorting control but Firestore IDs are fine.
    const docRef = await addDoc(collection(db, "messages"), newMessage);

    // Return with ID
    return { id: docRef.id, ...newMessage };
}

// Delete Message
async function deleteMessage(messageId) {
    if (!confirm('ã“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) return;

    await deleteDoc(doc(db, "messages", messageId));

    // Also delete replies? 
    // In NoSQL/Firestore, cascading delete is client-side or cloud function.
    // For simplicity, we just leave orphans or client filters them out.
    // Client side filter: !m.rootId matches...

    showToast('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
}

// Mark as Read
async function markMessagesAsRead(userId, partnerId, isSentHistory) {
    // This requires a query to find unread messages
    // It's complex to update header count instantly for specific user pairs without a batch update.

    // Query: toId == userId AND fromId == partnerId AND isRead == false
    const q = query(
        collection(db, "messages"),
        where("toId", "==", userId),
        where("fromId", "==", partnerId),
        where("isRead", "==", false)
    );

    const querySnapshot = await getDocs(q);

    // Batch update logic would be ideal, but for now loop is easy to write
    querySnapshot.forEach(async (document) => {
        // Apply logic for thread/history context from previous version if needed
        const data = document.data();

        // Logic from previous app.js:
        // if (isSentHistory === threadStartedByMe) ...
        // Complex to reproduce 1:1 without fetching parents.
        // Simplification: Mark all as read if we open the thread/history.

        const docRef = doc(db, "messages", document.id);
        await updateDoc(docRef, { isRead: true });
    });
}


// ============================
// UI Logic & State
// ============================

// Local State caches for rendering
let cachedMessages = [];
let cachedUsers = [];

// Listeners
let unsubscribeMessages = null;
let unsubscribeUsers = null;

// ... (Rest of UI Logic, heavily retained but updated for Async) ...
// We need to initialize listeners on login (main screen)

const elements = {}; // Re-populate

function initializeElements() {
    elements.loginScreen = document.getElementById('login-screen');
    elements.registerScreen = document.getElementById('register-screen');
    elements.mainScreen = document.getElementById('main-screen');

    if (elements.loginScreen) {
        elements.loginForm = document.getElementById('login-form');
        elements.usernameInput = document.getElementById('username');
        elements.passwordInput = document.getElementById('password');
    }

    if (elements.registerScreen) {
        elements.registerForm = document.getElementById('register-form');
        elements.regUserIdInput = document.getElementById('reg-userid');
        elements.regUsernameInput = document.getElementById('reg-username');
        elements.regPasswordInput = document.getElementById('reg-password');
    }

    if (elements.mainScreen) {
        // ... (Same as before)
        elements.currentUserBadge = document.getElementById('current-user');
        elements.logoutBtn = document.getElementById('logout-btn');
        elements.tabBtns = document.querySelectorAll('.tab-btn');
        elements.tabContents = document.querySelectorAll('.tab-content');
        elements.sendForm = document.getElementById('send-form');
        elements.recipientSelect = document.getElementById('recipient');
        elements.messageInput = document.getElementById('message');
        elements.timelineList = document.getElementById('timeline-list');
        elements.receivedBadge = document.getElementById('received-badge');
        elements.sentBadge = document.getElementById('sent-badge');

        elements.receivedSendersList = document.getElementById('received-senders-list');
        elements.receivedMessagesDetail = document.getElementById('received-messages-detail');
        elements.detailSenderName = document.getElementById('detail-sender-name');
        elements.detailMessagesList = document.getElementById('detail-messages-list');

        elements.sentRecipientsList = document.getElementById('sent-recipients-list');
        elements.sentMessagesDetail = document.getElementById('sent-messages-detail');
        elements.detailRecipientName = document.getElementById('detail-recipient-name');
        elements.detailSentMessagesList = document.getElementById('detail-sent-messages-list');

        elements.searchUserIdInput = document.getElementById('search-userid');
        elements.searchResult = document.getElementById('search-result');
        elements.followingList = document.getElementById('following-list');
        elements.blockedList = document.getElementById('blocked-list');
        elements.blockedListToggle = document.getElementById('blocked-list-toggle');
        elements.followerList = document.getElementById('follower-list');
        elements.followerListToggle = document.getElementById('follower-list-toggle');

        elements.followingListToggle = document.getElementById('following-list-toggle');

        elements.listTypeSelect = document.getElementById('list-type-select');
        elements.followingListWrapper = document.getElementById('following-list-wrapper');
        elements.followerListWrapper = document.getElementById('follower-list-wrapper');
        elements.blockedListWrapper = document.getElementById('blocked-list-wrapper');

        elements.searchSectionToggle = document.getElementById('search-section-toggle');
        elements.searchSectionContent = document.getElementById('search-section-content');

        elements.profileModal = document.getElementById('profile-modal');
        elements.closeModal = elements.profileModal.querySelector('.close-modal');
        elements.modalUsername = document.getElementById('modal-username');
        elements.usernameEdit = document.getElementById('username-edit');
        elements.modalUserid = document.getElementById('modal-userid');
        elements.modalFollowsYouBadge = document.getElementById('modal-follows-you-badge');
        elements.profileAvatarDisplay = document.getElementById('profile-avatar-display');
        elements.followingCount = document.getElementById('following-count');
        elements.followerCount = document.getElementById('follower-count');
        elements.bioDisplay = document.getElementById('bio-display');
        elements.bioEdit = document.getElementById('bio-edit');
        elements.avatarUpload = document.getElementById('avatar-upload');
        elements.avatarEditOverlay = document.getElementById('avatar-edit-overlay');

        elements.modalActionBtn = document.getElementById('modal-action-btn');
        elements.modalBlockBtn = document.getElementById('modal-block-btn');
        elements.modalEditBtn = document.getElementById('modal-edit-btn');
        elements.modalSaveBtn = document.getElementById('modal-save-btn');
        elements.modalCancelBtn = document.getElementById('modal-cancel-btn');
        elements.modalThanksBtn = document.getElementById('modal-thanks-btn');

        elements.threadModal = document.getElementById('thread-modal');
        elements.closeThreadModal = document.querySelector('.close-thread-modal');
        elements.threadMessagesList = document.getElementById('thread-messages-list');
        elements.threadReplyForm = document.getElementById('thread-reply-form');
        elements.threadInput = document.getElementById('thread-input');
    }

    elements.toast = document.getElementById('toast');
}


// Setup Realtime Listeners
function setupListeners() {
    // Listen for Messages
    const q = query(collection(db, "messages"), orderBy("createdAt", "desc"));
    unsubscribeMessages = onSnapshot(q, (snapshot) => {
        cachedMessages = [];
        snapshot.forEach((doc) => {
            cachedMessages.push({ id: doc.id, ...doc.data() });
        });

        // Re-render current views
        // Note: This is a brute force re-render. Optimization would check what screen is active.
        const activeTab = document.querySelector('.tab-btn.active')?.dataset.tab;

        if (activeTab === 'timeline') renderTimeline();
        else if (activeTab === 'received') renderReceivedMessages(); // This handles list vs detail check internally usually? No, we need to check.
        // Actually render functions usually rebuild list.

        // We always update badges
        updateAllBadges();

        // If detail views are open, update them
        if (currentReceivedPartnerId) showReceivedDetail(currentReceivedPartnerId);
        if (currentSentPartnerId) showSentDetail(currentSentPartnerId);
        if (currentThreadContext) renderThreadMessages();
    });

    // Listen for Users (e.g. if someone changes name, or I get followed)
    unsubscribeUsers = onSnapshot(collection(db, "users"), (snapshot) => {
        cachedUsers = [];
        snapshot.forEach((doc) => {
            cachedUsers.push(doc.data());
        });

        // Refresh my session data in case I was updated (e.g. followed/blocked)
        refreshCurrentUser().then(() => {
            const activeTab = document.querySelector('.tab-btn.active')?.dataset.tab;
            if (activeTab === 'friends') {
                renderFollowingList();
                renderFollowerList();
                renderBlockedList();
            }
        });
    });
}


// Re-implement Render Functions using cachedMessages/cachedUsers
// These are largely identical to original but use the global cached arrays.

function updateAllBadges(messagesInput) {
    const messages = messagesInput || cachedMessages;
    const currentUser = getCurrentUser();
    if (!currentUser) return;

    // Received Unread
    const blocked = currentUser.blocked || [];
    const receivedUnread = messages.filter(m =>
        m.toId === currentUser.userId &&
        !m.isRead &&
        !blocked.includes(m.fromId)
    ).length;
    updateReceivedBadge(receivedUnread);

    // Sent Unread (replies from others)
    const sentUnread = messages.filter(m =>
        m.toId === currentUser.userId && // sent TO me
        !m.isRead &&
        m.rootId && // is a reply
        // Check if the thread was started by me (simplified: assume replies to me are relevant)
        // Original logic was deeper, keeping it simple for now.
        !blocked.includes(m.fromId)
    ).length;
    updateSentBadge(sentUnread);
}


// ... (Paste utility functions: formatDate, escapeHtml, showToast, etc.) ...
// ... (Paste render functions: createMessageCard, renderTimeline, etc. using cachedMessages) ...
// ... (Paste event handlers: handleLogin -> async, etc.) ...

// I'll define essential helpers here to make the file complete in one go.

function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function formatDate(dateInput) {
    const date = new Date(dateInput);
    const yyyy = date.getFullYear();
    const mm = String(date.getMonth() + 1).padStart(2, '0');
    const dd = String(date.getDate()).padStart(2, '0');
    const hh = String(date.getHours()).padStart(2, '0');
    const min = String(date.getMinutes()).padStart(2, '0');
    return `${yyyy}/${mm}/${dd} ${hh}:${min}`;
}

function updateReceivedBadge(count) {
    if (!elements.receivedBadge) return;
    elements.receivedBadge.textContent = count > 0 ? count : '';
    count > 0 ? elements.receivedBadge.classList.remove('hidden') : elements.receivedBadge.classList.add('hidden');
}

function updateSentBadge(count) {
    if (!elements.sentBadge) return;
    elements.sentBadge.textContent = count > 0 ? count : '';
    count > 0 ? elements.sentBadge.classList.remove('hidden') : elements.sentBadge.classList.add('hidden');
}

let toastTimeout;
function showToast(message) {
    if (toastTimeout) clearTimeout(toastTimeout);
    const toastMessage = elements.toast.querySelector('.toast-message');
    toastMessage.textContent = message;
    elements.toast.classList.remove('hidden');
    elements.toast.classList.add('show');
    toastTimeout = setTimeout(() => {
        elements.toast.classList.remove('show');
        setTimeout(() => elements.toast.classList.add('hidden'), 300);
    }, 3000);
}

// ... Card Creation ...
function createMessageCard(msg, type = 'timeline', latestTime = null, hasUnread = false) {
    const currentUser = getCurrentUser();
    const isOwn = msg.fromId === currentUser.userId;

    // Determine card classes
    let cardClass = `message-card ${isOwn ? 'own-message' : ''}`;
    if (msg.isRead === false && msg.toId === currentUser.userId) {
        cardClass += ' unread';
    }

    // Thread Button
    const threadBtn = `<button class="reply-btn" onclick="window.openThread('${msg.id}')">ğŸ’¬ ã‚¹ãƒ¬ãƒƒãƒ‰</button>`;

    // Delete Button (only own)
    const deleteBtn = isOwn ? `<button class="delete-btn" onclick="window.deleteMessage('${msg.id}')">ğŸ—‘ï¸</button>` : '';

    // User Display
    let userDisplay = '';
    const nameStyle = 'cursor:pointer; text-decoration:underline;';

    if (type === 'timeline') {
        userDisplay = `
            <div class="message-users">
                <span class="message-from" style="${nameStyle}" onclick="event.stopPropagation(); window.showUserProfile('${msg.fromId}')">${escapeHtml(msg.fromName)}</span>
                <span class="message-arrow">â†’</span>
                <span class="message-to" style="${nameStyle}" onclick="event.stopPropagation(); window.showUserProfile('${msg.toId}')">${escapeHtml(msg.toName)}</span>
                ${threadBtn}
                ${deleteBtn}
            </div>
        `;
    } else if (type === 'received') {
        userDisplay = `<div class="message-users"><span class="message-from" style="${nameStyle}" onclick="event.stopPropagation(); window.showUserProfile('${msg.fromId}')">${escapeHtml(msg.fromName)}</span>${threadBtn}${deleteBtn}</div>`;
    } else if (type === 'sent') {
        userDisplay = `<div class="message-users"><span class="message-to" style="${nameStyle}" onclick="event.stopPropagation(); window.showUserProfile('${msg.toId}')">${escapeHtml(msg.toName)}</span>${threadBtn}${deleteBtn}</div>`;
    } else if (type === 'thread') {
        userDisplay = `
            <div class="message-users">
                <span class="message-from" style="${nameStyle}" onclick="event.stopPropagation(); window.showUserProfile('${msg.fromId}')">${escapeHtml(msg.fromName)}</span>
                ${deleteBtn}
            </div>
        `;
    }

    // Time & Badges
    const timeToUse = latestTime || msg.createdAt;
    const timeLabel = latestTime ? 'æœ€æ–°: ' : '';
    let extraBadges = '';

    return `
        <div class="${cardClass}" id="msg-${msg.id}">
            <div class="message-header">
                ${userDisplay}
                ${type !== 'thread' ? `
                <div class="message-meta" style="font-size: 0.8em; color: var(--text-secondary); display:flex; align-items:center;">
                    ${(msg.isRead === false && msg.toId === currentUser.userId) ? '<span class="badge" style="background:var(--pink-500); color:white; padding:2px 8px; border-radius:12px; font-size:0.8em; margin-right:6px;">New</span>' : ''}
                    ${timeLabel}${formatDate(timeToUse)}
                </div>` : ''}
            </div>

            <div class="message-body">
                ${msg.replyTo ? `
                    <div class="reply-context">
                        <span class="reply-link-name">${escapeHtml(msg.replyTo.name)}ã•ã‚“ã¸ã®è¿”ä¿¡</span>
                        "${escapeHtml(msg.replyTo.text)}"
                    </div>
                ` : ''}
                <div class="message-text">
                    ${escapeHtml(msg.message)}
                </div>
                <div class="message-footer" style="text-align: right; font-size: 0.75em; color: var(--text-light); margin-top: 4px;">
                    ${formatDate(msg.createdAt)}
                </div>
            </div>
        </div>
    `;
}

// ... Async Event Handlers ...

async function handleLogin(e) {
    e.preventDefault();
    const userId = elements.usernameInput.value.trim();
    const password = elements.passwordInput.value.trim();

    if (!userId || !password) {
        showToast('ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
        return;
    }

    try {
        const user = await findUser(userId);
        if (!user || user.password !== password) {
            showToast('ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã¾ãŸã¯ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé–“é•ã£ã¦ã„ã¾ã™');
            return;
        }

        setCurrentUser(user);
        showToast(`ãŠã‹ãˆã‚Šãªã•ã„ã€${user.name}ã•ã‚“ï¼`);
        setTimeout(() => window.location.href = 'top.html', 1000);
    } catch (err) {
        console.error(err);
        showToast('ãƒ­ã‚°ã‚¤ãƒ³ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
    }
}

async function handleRegister(e) {
    e.preventDefault();
    const userId = elements.regUserIdInput.value.trim();
    const username = elements.regUsernameInput.value.trim();
    const password = elements.regPasswordInput.value.trim();

    if (!userId || !username || !password) {
        showToast('ã™ã¹ã¦ã®é …ç›®ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
        return;
    }

    try {
        const newUser = await createUser(userId, username, password);
        setCurrentUser(newUser);
        showToast(`ã‚ˆã†ã“ãã€${username}ã•ã‚“ï¼`);
        setTimeout(() => window.location.href = 'top.html', 1000);
    } catch (err) {
        console.error(err);
        showToast('ç™»éŒ²ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸï¼ˆIDé‡è¤‡ãªã©ï¼‰');
    }
}

function handleLogout() {
    clearCurrentUser();
    window.location.href = 'index.html';
}

async function handleSendMessage(e) {
    e.preventDefault();
    const recipientId = elements.recipientSelect.value;
    const recipientOption = elements.recipientSelect.options[elements.recipientSelect.selectedIndex];
    const recipientName = recipientOption ? recipientOption.dataset.name : '';
    const message = elements.messageInput.value.trim();

    if (!recipientId || !message) return;

    const options = {};
    if (currentReplyContext) options.replyTo = currentReplyContext;

    try {
        await sendMessage(recipientId, recipientName, message, options);
        showToast(`${recipientName}ã•ã‚“ã«ã‚ã‚ŠãŒã¨ã†ã‚’é€ã‚Šã¾ã—ãŸï¼`);
        elements.messageInput.value = '';
        elements.recipientSelect.value = '';
        cancelReply();
        // UI updates automatically via listener
    } catch (err) {
        console.error(err);
        showToast('é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
}

// Global Wrappers for OnClick (Since module scope is not global)
window.showUserProfile = async (userId) => {
    // Need to implement showProfile logic fetching from cachedUsers or DB
    // For simplicity, fetch fresh
    const user = cachedUsers.find(u => u.userId === userId) || await findUser(userId);
    if (user) renderProfileModal(user);
};

window.toggleFollow = async (targetUserId) => {
    let currentUser = await refreshCurrentUser();
    if (!currentUser) return;

    const userRef = doc(db, "users", currentUser.userId);
    let isFollowing = currentUser.following && currentUser.following.includes(targetUserId);

    // Toggle logic
    if (isFollowing) {
        await updateDoc(userRef, {
            following: arrayRemove(targetUserId)
        });
        showToast('ãƒ•ã‚©ãƒ­ãƒ¼ã‚’è§£é™¤ã—ã¾ã—ãŸ');
        isFollowing = false; // Update local state immediately
    } else {
        await updateDoc(userRef, {
            following: arrayUnion(targetUserId)
        });
        showToast('ãƒ•ã‚©ãƒ­ãƒ¼ã—ã¾ã—ãŸ');
        isFollowing = true;
    }

    // Refresh global state
    currentUser = await refreshCurrentUser();

    // 1. Update Profile Modal if Open
    if (elements.profileModal.classList.contains('show') && currentProfileUserId === targetUserId) {
        elements.modalActionBtn.textContent = isFollowing ? 'ãƒ•ã‚©ãƒ­ãƒ¼ä¸­' : 'ãƒ•ã‚©ãƒ­ãƒ¼ã™ã‚‹';
        elements.modalActionBtn.className = 'btn btn-primary profile-action-btn';

        // Update Thanks Button state
        elements.modalThanksBtn.disabled = !isFollowing;
        elements.modalThanksBtn.className = isFollowing ? 'btn btn-success profile-action-btn' : 'btn btn-disabled-white profile-action-btn';
        elements.modalThanksBtn.style.opacity = '1';

        // Optimistically update follower count on the modal
        const currentCount = parseInt(elements.followerCount.textContent) || 0;
        elements.followerCount.textContent = isFollowing ? currentCount + 1 : Math.max(0, currentCount - 1);
    }

    // 2. Update Buttons in Lists (Search, Friends, Followers)
    const btns = document.querySelectorAll(`button[onclick="window.toggleFollow('${targetUserId}')"]`);
    btns.forEach(btn => {
        // Different text logic based on context, but generally:
        if (btn.closest('.user-card')) {
            btn.textContent = isFollowing ? 'ãƒ•ã‚©ãƒ­ãƒ¼ä¸­' : 'ãƒ•ã‚©ãƒ­ãƒ¼';
            btn.className = 'btn btn-sm btn-primary';
        }
    });

    // 3. If in Friends Tab, refresh lists to move/remove users if needed
    const activeTab = document.querySelector('.tab-btn.active');
    if (activeTab && activeTab.dataset.tab === 'friends') {
        renderFollowingList();
        renderFollowerList();
    }
};

window.toggleBlock = async (targetUserId) => {
    let currentUser = await refreshCurrentUser();
    if (!currentUser) return;

    if (!confirm('ã“ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãƒ–ãƒ­ãƒƒã‚¯/è§£é™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;

    const userRef = doc(db, "users", currentUser.userId);
    let blocked = currentUser.blocked || [];
    let isBlocked = blocked.includes(targetUserId);

    if (isBlocked) {
        await updateDoc(userRef, {
            blocked: arrayRemove(targetUserId)
        });
        showToast('ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã—ãŸ');
        isBlocked = false;
    } else {
        // Block and also Unfollow if following
        const updates = {
            blocked: arrayUnion(targetUserId)
        };

        if (currentUser.following && currentUser.following.includes(targetUserId)) {
            updates.following = arrayRemove(targetUserId);
        }

        await updateDoc(userRef, updates);
        showToast('ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸ');
        isBlocked = true;
    }

    // Refresh
    currentUser = await refreshCurrentUser();

    // 1. Update Profile Modal if Open
    if (elements.profileModal.classList.contains('show') && currentProfileUserId === targetUserId) {
        elements.modalBlockBtn.textContent = isBlocked ? 'ãƒ–ãƒ­ãƒƒã‚¯ä¸­' : 'ãƒ–ãƒ­ãƒƒã‚¯';
        elements.modalBlockBtn.className = isBlocked ? 'btn btn-blocking' : 'btn btn-danger';

        // Disable Follow button if blocked
        elements.modalActionBtn.disabled = isBlocked;
        elements.modalActionBtn.style.opacity = isBlocked ? '0.5' : '1';

        const isFollowing = currentUser.following && currentUser.following.includes(targetUserId);
        if (isBlocked) {
            elements.modalActionBtn.textContent = 'ãƒ•ã‚©ãƒ­ãƒ¼ä¸å¯';
            elements.modalActionBtn.className = 'btn btn-disabled-white';
        } else {
            elements.modalActionBtn.textContent = isFollowing ? 'ãƒ•ã‚©ãƒ­ãƒ¼ä¸­' : 'ãƒ•ã‚©ãƒ­ãƒ¼ã™ã‚‹';
            elements.modalActionBtn.className = 'btn btn-primary';
        }

        elements.modalThanksBtn.disabled = !isFollowing;
        elements.modalThanksBtn.className = isFollowing ? 'btn btn-success' : 'btn btn-disabled-white';
        elements.modalThanksBtn.style.opacity = '1';
    }

    // 2. Refresh Lists (Blocked list, etc)
    const activeTab = document.querySelector('.tab-btn.active');
    if (activeTab && activeTab.dataset.tab === 'friends') {
        renderBlockedList();
        // If we blocked someone we were following, logic might imply unfollowing or hiding...
        // For now just refresh displayed blocked list
    }
};


window.deleteMessage = async (msgId) => {
    await deleteMessage(msgId);
};

window.openThread = (msgId) => {
    // Logic to open thread modal
    // ... Copy openThread logic but fetch from cachedMessages
    const msg = cachedMessages.find(m => m.id === msgId);
    if (!msg) return;

    const currentUser = getCurrentUser();
    const rootId = msg.rootId || msg.id;
    const otherId = (msg.fromId === currentUser.userId) ? msg.toId : msg.fromId;
    const otherName = (msg.fromId === currentUser.userId) ? msg.toName : msg.fromName;

    currentThreadContext = { rootId, otherUserId: otherId, otherUserName: otherName };
    renderThreadMessages();

    const modal = document.getElementById('thread-modal');
    modal.classList.remove('hidden');
    void modal.offsetWidth;
    modal.classList.add('show');
};

// ... Render Implementations needed for window.openThread etc to work ...
let currentThreadContext = null;
let currentProfileUserId = null;
let currentReceivedPartnerId = null;
let currentSentPartnerId = null;

function renderThreadMessages() {
    if (!currentThreadContext) return;
    const listContainer = document.getElementById('thread-messages-list');
    listContainer.innerHTML = '';

    const threadMessages = cachedMessages.filter(m =>
        m.rootId === currentThreadContext.rootId || m.id === currentThreadContext.rootId
    ).sort((a, b) => a.createdAt - b.createdAt);

    if (threadMessages.length === 0) {
        listContainer.innerHTML = '<p>No messages</p>';
        return;
    }

    threadMessages.forEach(msg => {
        listContainer.innerHTML += createMessageCard(msg, 'thread');
    });

    setTimeout(() => listContainer.scrollTop = listContainer.scrollHeight, 10);
}

// ============================
// Render Functions (Implemented)
// ============================

function renderUserCard(user, type = 'following') {
    const currentUser = getCurrentUser();
    const isMe = user.userId === currentUser.userId;
    const isFollowing = currentUser.following && currentUser.following.includes(user.userId);

    // Check if they follow you
    const followsYou = user.following && user.following.includes(currentUser.userId);

    let actionBtn = '';
    if (!isMe) {
        if (type === 'search') {
            actionBtn = `<button class="btn btn-sm btn-primary" onclick="window.toggleFollow('${user.userId}')">
                ${isFollowing ? 'ãƒ•ã‚©ãƒ­ãƒ¼ä¸­' : 'ãƒ•ã‚©ãƒ­ãƒ¼'}
            </button>`;
        } else if (type === 'blocked') {
            actionBtn = `<button class="btn btn-sm btn-outline" onclick="window.toggleBlock('${user.userId}')">è§£é™¤</button>`;
        } else { // following / follower
            actionBtn = `<button class="btn btn-sm btn-primary" onclick="window.toggleFollow('${user.userId}')">
                ${isFollowing ? 'ãƒ•ã‚©ãƒ­ãƒ¼ä¸­' : 'ãƒ•ã‚©ãƒ­ãƒ¼'}
            </button>`;
        }
    }

    return `
        <div class="message-card user-card">
            <div class="user-card-content" onclick="window.showUserProfile('${user.userId}')" style="cursor:pointer; display:flex; align-items:center; gap:12px; flex:1;">
                <div class="profile-avatar sm">${user.avatar || 'ğŸ‘¤'}</div>
                <div class="user-info">
                    <div class="user-name">
                        ${escapeHtml(user.name)}
                        ${followsYou ? '<span class="follows-you-badge">ãƒ•ã‚©ãƒ­ãƒ¼ã•ã‚Œã¦ã„ã¾ã™</span>' : ''}
                    </div>
                    <div class="user-id">@${user.userId}</div>
                </div>
            </div>
            ${actionBtn}
        </div>
    `;
}

function renderReceivedMessages() {
    const currentUser = getCurrentUser();
    if (!currentUser) return;
    const blocked = currentUser.blocked || [];

    const messages = cachedMessages.filter(m =>
        m.toId === currentUser.userId &&
        !blocked.includes(m.fromId)
    );

    const senders = {};
    messages.forEach(msg => {
        if (!senders[msg.fromId]) {
            senders[msg.fromId] = {
                id: msg.fromId,
                name: msg.fromName,
                lastMessage: msg,
                count: 0,
                unread: 0
            };
        }
        if (msg.createdAt > senders[msg.fromId].lastMessage.createdAt) {
            senders[msg.fromId].lastMessage = msg;
        }
        senders[msg.fromId].count++;
        if (!msg.isRead) senders[msg.fromId].unread++;
    });

    // Additional Step: Check for MY replies to these senders to update the "Latest Date"
    Object.values(senders).forEach(sender => {
        const myReplies = cachedMessages.filter(m =>
            m.fromId === currentUser.userId &&
            m.toId === sender.id
        );
        if (myReplies.length > 0) {
            // Find latest reply
            const latestReply = myReplies.sort((a, b) => b.createdAt - a.createdAt)[0];
            if (latestReply.createdAt > sender.lastMessage.createdAt) {
                sender.lastMessage = latestReply;
            }
        }
    });

    const listContainer = elements.receivedSendersList;
    if (!listContainer) return;
    listContainer.innerHTML = '';
    elements.receivedMessagesDetail.classList.add('hidden');
    listContainer.classList.remove('hidden');

    const sortedSenders = Object.values(senders).sort((a, b) => b.lastMessage.createdAt - a.lastMessage.createdAt);

    if (sortedSenders.length === 0) {
        listContainer.innerHTML = '<div class="empty-state"><span class="empty-icon">ğŸ“­</span><p>ã¾ã ã‚ã‚ŠãŒã¨ã†ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã‚ã‚Šã¾ã›ã‚“</p></div>';
        return;
    }

    sortedSenders.forEach(sender => {
        const div = document.createElement('div');
        div.className = `message-card ${sender.unread > 0 ? 'unread' : ''}`;
        div.style.cursor = 'pointer';
        div.onclick = () => showReceivedDetail(sender.id);

        div.innerHTML = `
            <div class="message-header">
                <span class="message-from" style="font-weight:bold; font-size:1.1em; cursor:pointer;" onclick="event.stopPropagation(); window.showUserProfile('${sender.id}')">
                    ${escapeHtml(sender.name)}
                </span>
                <div style="display:flex; align-items:center; gap:8px;">
                     ${sender.unread > 0 ? '<span class="badge" style="background:var(--pink-500); color:white; padding:2px 8px; border-radius:12px; font-size:0.8em;">New</span>' : ''}
                     <span style="font-size:0.8em; color:var(--text-light);">${formatDate(sender.lastMessage.createdAt)}</span>
                </div>
            </div>
             <div class="message-body" style="margin-top:8px;">
                <div class="message-text" style="color:var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                    ${escapeHtml(sender.lastMessage.message)}
                </div>
            </div>
        `;
        listContainer.appendChild(div);
    });
}

window.showReceivedDetail = (senderId) => {
    currentReceivedPartnerId = senderId;
    const currentUser = getCurrentUser();

    // Mark as read
    markMessagesAsRead(currentUser.userId, senderId, false);

    const messages = cachedMessages.filter(m =>
        m.toId === currentUser.userId &&
        m.fromId === senderId &&
        !m.rootId
    ).sort((a, b) => b.createdAt - a.createdAt);

    if (messages.length === 0) return;

    elements.receivedSendersList.classList.add('hidden');
    elements.receivedMessagesDetail.classList.remove('hidden');
    elements.detailSenderName.textContent = messages[0].fromName; // Use latest name

    // Calculate Latest Dates including replies
    const threadLatest = {};
    cachedMessages.forEach(m => {
        const rootId = m.rootId || m.id;
        if (!threadLatest[rootId] || m.createdAt > threadLatest[rootId]) {
            threadLatest[rootId] = m.createdAt;
        }
    });

    elements.detailMessagesList.innerHTML = messages.map(msg => {
        const latestAt = threadLatest[msg.id] || msg.createdAt;
        return createMessageCard(msg, 'received', latestAt);
    }).join('');
}

window.backToReceivedList = () => {
    currentReceivedPartnerId = null;
    elements.receivedMessagesDetail.classList.add('hidden');
    elements.receivedSendersList.classList.remove('hidden');
    renderReceivedMessages(); // Re-render to update unread status
};

function renderSentMessages() {
    const currentUser = getCurrentUser();
    if (!currentUser) return;
    // Sent messages logic...
    const messages = cachedMessages.filter(m =>
        m.fromId === currentUser.userId
    );

    const recipients = {};
    messages.forEach(msg => {
        if (!recipients[msg.toId]) {
            recipients[msg.toId] = {
                id: msg.toId,
                name: msg.toName, // Snapshot name
                lastMessage: msg,
                count: 0
            };
        }
        if (msg.createdAt > recipients[msg.toId].lastMessage.createdAt) {
            recipients[msg.toId].lastMessage = msg;
        }
        recipients[msg.toId].count++;
    });

    const listContainer = elements.sentRecipientsList;
    listContainer.innerHTML = '';
    elements.sentMessagesDetail.classList.add('hidden');
    listContainer.classList.remove('hidden');

    const sortedRecipients = Object.values(recipients).sort((a, b) => b.lastMessage.createdAt - a.lastMessage.createdAt);

    if (sortedRecipients.length === 0) {
        listContainer.innerHTML = '<div class="empty-state"><span class="empty-icon">âœ¨</span><p>ã¾ã ã‚ã‚ŠãŒã¨ã†ã‚’é€ã£ã¦ã„ã¾ã›ã‚“</p></div>';
        return;
    }

    sortedRecipients.forEach(pf => {
        const div = document.createElement('div');
        div.className = 'message-card own-message';
        div.style.cursor = 'pointer';
        div.onclick = () => showSentDetail(pf.id);
        div.innerHTML = `
             <div class="message-header">
                <span class="message-to" style="font-weight:bold; font-size:1.1em; cursor:pointer;" onclick="event.stopPropagation(); window.showUserProfile('${pf.id}')">
                    ${escapeHtml(pf.name)}
                </span>
                 <span style="font-size:0.8em; color:var(--text-light);">${formatDate(pf.lastMessage.createdAt)}</span>
            </div>
             <div class="message-body" style="margin-top:8px;">
                <div class="message-text" style="color:var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                    ${escapeHtml(pf.lastMessage.message)}
                </div>
            </div>
        `;
        listContainer.appendChild(div);
    });
}

window.showSentDetail = (recipientId) => {
    currentSentPartnerId = recipientId;
    const currentUser = getCurrentUser();

    const messages = cachedMessages.filter(m =>
        m.fromId === currentUser.userId &&
        m.toId === recipientId &&
        !m.rootId
    ).sort((a, b) => b.createdAt - a.createdAt);

    if (messages.length === 0) return;

    elements.sentRecipientsList.classList.add('hidden');
    elements.sentMessagesDetail.classList.remove('hidden');
    elements.detailRecipientName.textContent = messages[0].toName;

    // Calculate Latest Dates including replies
    const threadLatest = {};
    cachedMessages.forEach(m => {
        const rootId = m.rootId || m.id;
        if (!threadLatest[rootId] || m.createdAt > threadLatest[rootId]) {
            threadLatest[rootId] = m.createdAt;
        }
    });

    elements.detailSentMessagesList.innerHTML = messages.map(msg => {
        const latestAt = threadLatest[msg.id] || msg.createdAt;
        return createMessageCard(msg, 'sent', latestAt);
    }).join('');
};

window.backToSentList = () => {
    currentSentPartnerId = null;
    elements.sentMessagesDetail.classList.add('hidden');
    elements.sentRecipientsList.classList.remove('hidden');
};

function renderFollowingList() {
    const currentUser = getCurrentUser();
    if (!currentUser || !elements.followingList) return;
    const followingIds = currentUser.following || [];
    const container = elements.followingList;
    container.innerHTML = '';
    const followingUsers = cachedUsers.filter(u => followingIds.includes(u.userId));

    if (followingUsers.length === 0) {
        container.innerHTML = '<div class="empty-state"><span class="empty-icon">ğŸ‘¥</span><p>ã¾ã ãƒ•ã‚©ãƒ­ãƒ¼ã—ã¦ã„ã‚‹äººã¯ã„ã¾ã›ã‚“</p></div>';
    } else {
        followingUsers.forEach(user => {
            container.innerHTML += renderUserCard(user, 'following');
        });
    }
    updateRecipientSelect(followingUsers);
}

function renderFollowerList() {
    const currentUser = getCurrentUser();
    if (!currentUser || !elements.followerList) return;
    const container = elements.followerList;
    container.innerHTML = '';
    // Filter users who follow me
    const followers = cachedUsers.filter(u => u.following && u.following.includes(currentUser.userId));

    if (followers.length === 0) {
        container.innerHTML = '<div class="empty-state"><span class="empty-icon">ğŸ‘¥</span><p>ã¾ã ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã¯ã„ã¾ã›ã‚“</p></div>';
    } else {
        followers.forEach(user => {
            container.innerHTML += renderUserCard(user, 'followers');
        });
    }
}

function renderBlockedList() {
    const currentUser = getCurrentUser();
    if (!currentUser || !elements.blockedList) return;
    const blockedIds = currentUser.blocked || [];
    const container = elements.blockedList;
    container.innerHTML = '';
    const blockedUsers = cachedUsers.filter(u => blockedIds.includes(u.userId));

    if (blockedUsers.length === 0) {
        container.innerHTML = '<div class="empty-state"><span class="empty-icon">ğŸš«</span><p>ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã„ã‚‹äººã¯ã„ã¾ã›ã‚“</p></div>';
    } else {
        blockedUsers.forEach(user => {
            container.innerHTML += renderUserCard(user, 'blocked');
        });
    }
}

function renderSearchResult() {
    const queryStr = elements.searchUserIdInput.value.trim();
    const container = elements.searchResult;
    if (!queryStr) {
        container.innerHTML = '';
        return;
    }
    // Strict match for User ID only
    const results = cachedUsers.filter(u => u.userId === queryStr);

    if (results.length === 0) {
        container.innerHTML = '<p style="text-align:center; padding:16px; color:var(--text-light);">ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒå®Œå…¨ã«ä¸€è‡´ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ</p>';
    } else {
        container.innerHTML = results.map(u => renderUserCard(u, 'search')).join('');
    }
}

function updateRecipientSelect(friends) {
    if (!elements.recipientSelect) return;
    elements.recipientSelect.innerHTML = '<option value="">â–¼ é€ã‚ŠãŸã„ç›¸æ‰‹ã‚’é¸ã‚“ã§ãã ã•ã„</option>';
    friends.forEach(user => {
        const option = document.createElement('option');
        option.value = user.userId;
        option.textContent = `${user.name} (@${user.userId})`;
        option.dataset.name = user.name;
        elements.recipientSelect.appendChild(option);
    });
}

function renderProfileModal(user) {
    currentProfileUserId = user.userId;
    const currentUser = getCurrentUser();
    if (!currentUser) return;

    elements.modalUsername.textContent = user.name;
    elements.modalUserid.textContent = `@${user.userId}`;
    elements.profileAvatarDisplay.textContent = user.avatar || 'ğŸ‘¤';
    elements.bioDisplay.textContent = user.bio || 'è‡ªå·±ç´¹ä»‹ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“';

    // Stats
    const followingCount = user.following ? user.following.length : 0;
    // Calculating followers strictly needs iterating all users (expensive) or storing it.
    // We'll iterate cachedUsers for now.
    const followerCount = cachedUsers.filter(u => u.following && u.following.includes(user.userId)).length;

    elements.followingCount.textContent = followingCount;
    elements.followerCount.textContent = followerCount;

    // Reset Edit Mode
    elements.bioDisplay.classList.remove('hidden');
    elements.bioEdit.classList.add('hidden');
    elements.usernameEdit.classList.add('hidden');
    elements.modalUsername.classList.remove('hidden');
    elements.avatarEditOverlay.classList.add('hidden');

    elements.modalEditBtn.classList.add('hidden');
    elements.modalSaveBtn.classList.add('hidden');
    elements.modalCancelBtn.classList.add('hidden');
    elements.modalActionBtn.classList.add('hidden');
    elements.modalBlockBtn.classList.add('hidden');
    elements.modalThanksBtn.classList.add('hidden');

    // Check following status for Thanks button disabling
    const isFollowing = currentUser.following && currentUser.following.includes(user.userId);

    if (user.userId === currentUser.userId) {
        // Own Profile
        elements.modalEditBtn.classList.remove('hidden');
        elements.modalFollowsYouBadge.classList.add('hidden');
        elements.modalThanksBtn.classList.add('hidden'); // Ensure hidden for self
    } else {
        // Other User
        // const isFollowing = ... already calculated above
        const isBlocked = currentUser.blocked && currentUser.blocked.includes(user.userId);

        // Follow Button Logic
        if (isBlocked) {
            elements.modalActionBtn.textContent = 'ãƒ•ã‚©ãƒ­ãƒ¼ä¸å¯';
            elements.modalActionBtn.className = 'btn btn-disabled-white profile-action-btn';
        } else {
            elements.modalActionBtn.textContent = isFollowing ? 'ãƒ•ã‚©ãƒ­ãƒ¼ä¸­' : 'ãƒ•ã‚©ãƒ­ãƒ¼ã™ã‚‹';
            elements.modalActionBtn.className = 'btn btn-primary profile-action-btn';
        }
        elements.modalActionBtn.onclick = () => window.toggleFollow(user.userId);
        elements.modalActionBtn.classList.remove('hidden');

        // Disable Follow button if blocked
        elements.modalActionBtn.disabled = isBlocked;
        elements.modalActionBtn.style.opacity = '1';

        // Thanks Button Logic
        elements.modalThanksBtn.classList.remove('hidden');
        elements.modalThanksBtn.disabled = !isFollowing; // Disable if not following
        elements.modalThanksBtn.className = isFollowing ? 'btn btn-success profile-action-btn' : 'btn btn-disabled-white profile-action-btn';
        elements.modalThanksBtn.style.opacity = '1';
        elements.modalThanksBtn.onclick = () => {
            if (!elements.modalThanksBtn.disabled) {
                elements.profileModal.classList.remove('show');
                setTimeout(() => elements.profileModal.classList.add('hidden'), 300);
                switchTab('send');
                elements.recipientSelect.value = user.userId;
            }
        };

        // Block Button Logic
        elements.modalBlockBtn.textContent = isBlocked ? 'ãƒ–ãƒ­ãƒƒã‚¯ä¸­' : 'ãƒ–ãƒ­ãƒƒã‚¯';
        elements.modalBlockBtn.className = isBlocked ? 'btn btn-blocking profile-action-btn' : 'btn btn-danger profile-action-btn';
        elements.modalBlockBtn.onclick = () => window.toggleBlock(user.userId);
        elements.modalBlockBtn.classList.remove('hidden');

        const followsYou = user.following && user.following.includes(currentUser.userId);
        followsYou ? elements.modalFollowsYouBadge.classList.remove('hidden') : elements.modalFollowsYouBadge.classList.add('hidden');
    }

    elements.profileModal.classList.remove('hidden');
    void elements.profileModal.offsetWidth;
    elements.profileModal.classList.add('show');
}
// Actually, I must implement them all or the app breaks.
// I will paste the previous render logic but pointing to cachedMessages.

function renderTimeline() {
    const currentUser = getCurrentUser();
    if (!currentUser) return;
    const blocked = currentUser.blocked || [];

    // 1. Calculate latest timestamp for each thread
    const threadLatest = {};
    cachedMessages.forEach(m => {
        const rootId = m.rootId || m.id;
        if (!threadLatest[rootId] || m.createdAt > threadLatest[rootId]) {
            threadLatest[rootId] = m.createdAt;
        }
    });

    // 2. Filter for visible root messages
    const messages = cachedMessages.filter(m =>
        (m.fromId === currentUser.userId || m.toId === currentUser.userId) &&
        !m.rootId &&
        !blocked.includes(m.fromId)
    );

    if (messages.length === 0) {
        elements.timelineList.innerHTML = '<div class="empty-state"><span class="empty-icon">ğŸ“±</span><p>ã¾ã ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã‚ã‚Šã¾ã›ã‚“</p></div>';
    } else {
        // 3. Sort by calculated latest timestamp
        const sortedMessages = messages.sort((a, b) => {
            const timeA = threadLatest[a.id] || a.createdAt;
            const timeB = threadLatest[b.id] || b.createdAt;
            return timeB - timeA;
        });

        // 4. Render
        const html = sortedMessages.map(msg => {
            const latestAt = threadLatest[msg.id] || msg.createdAt;
            return createMessageCard(msg, 'timeline', latestAt);
        }).join('');

        elements.timelineList.innerHTML = html;
    }
}

// Initialization Logic
function initialize() {
    initializeElements();

    if (document.getElementById('login-screen') || document.getElementById('register-screen')) {
        if (elements.loginForm) elements.loginForm.addEventListener('submit', handleLogin);
        if (elements.registerForm) elements.registerForm.addEventListener('submit', handleRegister);
    }

    if (document.getElementById('main-screen')) {
        const currentUser = getCurrentUser();
        if (!currentUser) {
            window.location.href = 'index.html';
            return;
        }

        // Display Current User Name
        if (elements.currentUserBadge) {
            elements.currentUserBadge.textContent = currentUser.name;
            elements.currentUserBadge.addEventListener('click', () => {
                renderProfileModal(currentUser);
            });
        }

        elements.logoutBtn.addEventListener('click', handleLogout);
        elements.sendForm.addEventListener('submit', handleSendMessage);
        elements.tabBtns.forEach(btn => btn.addEventListener('click', handleTabClick));

        // Setup Listeners
        setupListeners();

        // Initial Tab
        switchTab('timeline');

        // Friend List Toggles
        if (elements.listTypeSelect) {
            elements.listTypeSelect.addEventListener('change', (e) => {
                const type = e.target.value;
                elements.followingListWrapper.classList.toggle('hidden', type !== 'following');
                elements.followerListWrapper.classList.toggle('hidden', type !== 'followers');
                elements.blockedListWrapper.classList.toggle('hidden', type !== 'blocked');
            });
        }

        if (elements.searchSectionToggle) {
            elements.searchSectionToggle.addEventListener('click', () => {
                const content = elements.searchSectionContent;
                const icon = elements.searchSectionToggle.querySelector('.toggle-icon');
                const isHidden = content.style.display === 'none';
                content.style.display = isHidden ? 'block' : 'none';
                icon.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
                elements.searchSectionToggle.classList.toggle('collapsed', !isHidden);
            });
        }

        if (elements.searchUserIdInput) {
            elements.searchUserIdInput.addEventListener('input', renderSearchResult);
        }

        // Profile Actions
        if (elements.modalEditBtn) {
            elements.modalEditBtn.addEventListener('click', toggleProfileEdit);
            elements.modalCancelBtn.addEventListener('click', toggleProfileEdit);
            elements.modalSaveBtn.addEventListener('click', handleSaveProfile);
            elements.avatarEditOverlay.addEventListener('click', () => elements.avatarUpload.click());
            elements.avatarUpload.addEventListener('change', handleAvatarUpload);
            elements.avatarUpload.addEventListener('change', handleAvatarUpload);
        }

        // Modal Close Buttons
        if (elements.closeModal) {
            elements.closeModal.addEventListener('click', () => {
                elements.profileModal.classList.remove('show');
                setTimeout(() => elements.profileModal.classList.add('hidden'), 300);
            });
        }
        if (elements.closeThreadModal) {
            elements.closeThreadModal.addEventListener('click', () => {
                elements.threadModal.classList.remove('show');
                setTimeout(() => elements.threadModal.classList.add('hidden'), 300);
            });
        }

        // Thread Reply
        if (elements.threadReplyForm) {
            elements.threadReplyForm.addEventListener('submit', handleThreadReply);
        }

    }

}

// Tab Switching
function switchTab(tabName) {
    elements.tabBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tabName));
    elements.tabContents.forEach(content => content.classList.toggle('active', content.id === `tab-${tabName}`));

    if (tabName === 'timeline') renderTimeline();
    else if (tabName === 'received') renderReceivedMessages();
    else if (tabName === 'sent') renderSentMessages();
    else if (tabName === 'friends') {
        renderFollowingList();
        renderFollowerList();
        renderBlockedList();
    }
}
function handleTabClick(e) {
    const tabBtn = e.target.closest('.tab-btn');
    if (tabBtn) switchTab(tabBtn.dataset.tab);
}

// Profile View Helpers
function toggleProfileEdit() {
    const isEditing = !elements.bioDisplay.classList.contains('hidden');
    elements.bioDisplay.classList.toggle('hidden', isEditing);
    elements.bioEdit.classList.toggle('hidden', !isEditing);
    elements.usernameEdit.classList.toggle('hidden', !isEditing);
    elements.modalUsername.classList.toggle('hidden', isEditing);
    elements.avatarEditOverlay.classList.toggle('hidden', !isEditing);

    elements.modalEditBtn.classList.toggle('hidden', isEditing);
    elements.modalSaveBtn.classList.toggle('hidden', !isEditing);
    elements.modalCancelBtn.classList.toggle('hidden', !isEditing);

    if (isEditing) {
        elements.bioEdit.value = elements.bioDisplay.textContent === 'è‡ªå·±ç´¹ä»‹ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“' ? '' : elements.bioDisplay.textContent;
        elements.usernameEdit.value = elements.modalUsername.textContent;
    }
}

async function handleSaveProfile() {
    const currentUser = getCurrentUser();
    if (!currentUser) return;

    const newName = elements.usernameEdit.value.trim();
    const newBio = elements.bioEdit.value.trim();

    if (!newName) {
        showToast('åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
        return;
    }

    try {
        const userRef = doc(db, "users", currentUser.userId);
        await updateDoc(userRef, {
            name: newName,
            bio: newBio
        });

        // Update UI immediately (Important for immediate feedback)
        elements.modalUsername.textContent = newName;
        elements.bioDisplay.textContent = newBio || 'è‡ªå·±ç´¹ä»‹ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“';

        // Update Local Storage Session
        currentUser.name = newName;
        currentUser.bio = newBio;
        setCurrentUser(currentUser);

        // Update Header Badge
        if (elements.currentUserBadge) {
            elements.currentUserBadge.textContent = newName;
        }

        showToast('ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ');
        toggleProfileEdit();
    } catch (err) {
        console.error(err);
        showToast('æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
}

async function handleAvatarUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    showToast('ç”»åƒã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ã¯ç¾åœ¨Emoijã®ã¿å¯¾å¿œã—ã¦ã„ã¾ã™ï¼ˆå°†æ¥çš„ã«Storageã«å¯¾å¿œäºˆå®šï¼‰');
}

async function handleThreadReply(e) {
    e.preventDefault();
    const message = elements.threadInput.value.trim();
    if (!message || !currentThreadContext) return;

    try {
        await sendMessage(
            currentThreadContext.otherUserId,
            currentThreadContext.otherUserName,
            message,
            { rootId: currentThreadContext.rootId }
        );
        elements.threadInput.value = '';
        renderThreadMessages(); // Optimistic update or wait for listener? Listener handles it but better to scroll
        // renderThreadMessages will be called by listener eventually, but we might want immediate feedback
    } catch (err) {
        console.error(err);
        showToast('è¿”ä¿¡ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
}



// Start
document.addEventListener('DOMContentLoaded', initialize);

